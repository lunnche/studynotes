# Ubuntu 20.04 LTS 安装

Ubuntu 20.04 LTS 代号 Focal Fossa，于 2020 年 4 月 23 日正式发布，Ubuntu 20.04 LTS 附带 Kernel 5.4、GNOME 3.36、ZFS 安装支持更快的启动速度、GameMode 性能工具、Snap Store（用于替代 Ubuntu Software）。Ubuntu 20.04 LTS 的支持周期长达 5 年，同时适用于 Ubuntu Desktop、Ubuntu Server、Ubuntu Cloud 和 Ubuntu Core，其安全和维护更新直到 2025 年 4 月才到期。其余 flavour 的支持也长达 3 年。

背后有一个公司在支持，稳定性最好的Linux版本之一，可用来做server，manjaro运维团队人少，大部分新手，做服务器不稳定。

## 准备工作

Ubuntu有LTS版本和“技术前沿版”，这两种版本都可以作为日常的桌面终端进行使用，但通常我们会认为LTS版本更加稳定，而且可以获得至发行之日起为期5年的技术支持。而LTS版本之间发行的所谓“技术前沿版”仅有9个月的支持周期，到期之后用户就必需升级到新的版本下。

再有就是32位和64位版本选择的问题。之前有一个比较流行的说法是内存小于3GB时就不要选择64位版本进行安装，其实这种说法可以忽略不计，64位可以更加充分的利用CPU支持，哪怕你的内存小于3GB。

选择一个8g或以上容量的U盘，推荐USB3.0接口，速度快。

对U盘格式化。

用Rufus或Universal USB Installer等刻录软件制作启动U盘。

为Ubuntu腾出40G以上硬盘空间：在桌面右击`计算机`,选择`管理`，点击左侧`磁盘管理`，在你的机械硬盘或固态硬盘上分出一个大于40G的空间（如果你只是体验的话，只需要20G不到就好了）。具体为右击你要分区的磁盘，选择`压缩卷`，填入你要压缩的空间大小。

BIOS关闭Secure Boot：以联想电脑为例， 重启电脑，一直狂戳`F2`(有的电脑是F1，有的电脑是`Esc`,自行查询)，直到进入BIOS，点击方向箭头→ 移动到Security，再按↓移动到Secure Boot上，点击`回车键`，选择`Disable`，去Boot里面看看USB Boot是否为Enabled。

> **关于无法读出硬盘**（一般不用管）
>
> 需要在BIOS中将SATA Controller Mode选为ACHI模式，最后，按`F10`保存退出。
>  （更新）这里有个问题，改完SATA  Controller Mode装完Ubuntu后无法进入Windows的解决方案是改完进入Windows的安全模式，然后重启就正常了

退出BIOS后，保持U盘不拔下来，狂戳`F12`（不同电脑可能不同）,在出现的界面选择你的U盘。

## 从U盘安装

1 单击“安装Ubuntu”

2 选择键盘布局 Chinese-Chinese

3 有 2 种安装模式可供选择：

- **正常安装** 安装功能强大的桌面所需的所有应用程序，包括：Web 浏览器、办公套件、游戏和媒体播放器等。
- **最小安装** 安装最小的桌面版本，该版本仅具有 Web 浏览器和一些基本实用程序。

可以在安装 Ubuntu 20.04 LTS 桌面版的同时勾选「安装 Ubuntu 时下载更新」选项以下载并应用更新，也可以选择是否同时（推荐选上）「为图形或无线硬件，以及其它媒体格式安装第三方软件」。

4 如果当前计算机没有操作系统，则安装程序将提供以下两个选项：

- 清除整个磁盘并安装 Ubuntu

  此选项将删除磁盘中的所有内容，还有一个称为「Advanced Features」（高级功能）的附加选项，让您可以有如下 3 个附加选项。

  - 在 Ubuntu 新安装中使用 ZFS
  - （可选）加密 Ubuntu 新安装以提高安全性
  - EXPERIMENTAL – 擦除磁盘并使用ZFS

- **其它选项** 此选项允许手动对硬盘进行分区，可以为每个分区设置自定义大小，选择使用 Windows 和/或其他操作系统进行双重引导。

不想写了 瞎装吧 能用就行 费那劲

# Linux
# shell

一说到命令行，我们真正指的是shell。shell就是一个程序，它接受从键盘输入的命令，然后把命令传递给操作系统去执行。几乎所有的Linux发行版都提供一个名为bash的来自GNU项目的shell程序。"bash"是"Bourne Again SHell"的首字母缩写，所指的是这样一个事实，bash是最初Unix上由Steve Bourne写成shell程序sh的增强版。

## 终端仿真器
当使用图形用户界面时，我们需要另一个和shell交互的叫做终端仿真器的程序。如果浏览下桌面菜单，可能会找到一个。虽然在菜单里它可能都被简单地称为"terminal"，但是KDE用的是konsole，而GNOME则使用gnome-terminal。还有其他一些终端仿真器可供Linux使用，但基本上它们都完成同样的事情，让我们能访问shell。

`$`叫做shell提示符，无论何时shell准备好去接受输入时，它就会出现。
它通常包括你的用户名@主机名，紧接着当前工作目录和一个美元符号。
如果提示符的最后一个字符是“#”，而不是“\$”，那么这个终端会话就有超级用户（管理员）权限。这意味我们或者是以root用户的身份登录，或者是我们选择的终端仿真器提供超级用户（管理员）权限。
## 命令历史
按下 上箭头，上次输入的命令会复现，这叫命令历史。许多Linux发行版默认保存最后输入的500个命令。按下 下箭头，先前输入的命令就消失了。
## 鼠标和光标
可以在终端仿真器里使用鼠标。X窗口系统（使GUI工作的底层引擎）内建了一种机制，支持快速拷贝和粘贴技巧。按下鼠标左键，沿着文本拖动鼠标（或者双击一个单词）高亮了一些文本，那么这些高亮的文本就拷贝到了一个由X管理的缓冲区里面。然后按下鼠标中键，这些文本就被粘贴到光标所在的位置
注意：不要再一个终端窗口里使用`Ctrl-c`和`Ctrl-v`快捷键来执行拷贝和粘贴操作。它们不起作用。对于shell来说，这两个控制代码有着不同的含义，它们在早于Microsoft Windows（定义复制粘贴的含义）许多年之前就赋予了不同的意义。
你的图形桌面环境（像KDE或GNOME），努力想和Windows一样，可能会把它的聚焦策略设置成“单击聚焦”。这意味着，为了让窗口聚焦（变成活动窗口）你需要单击它。这与“聚焦跟随鼠标”的传统X行为不同，传统X行为是指只要把鼠标移动到一个窗口上方。它能接受输入，但是直到你单击窗口之前它都不会称为前段窗口。设置聚焦策略为“聚焦跟随着鼠标”，可以使拷贝和粘贴更方便易用。可以在窗口管理器的配置程序中找到这个设置。
## 试试运行一些简单命令
date 显示系统当前时间和日期
cal 显示当前月份的日历
df 查看磁盘剩余空间的数量
free 显示空闲内存数量
exit 结束终端会话

## 幕后控制台
即使终端仿真器没有运行，在后台仍然有几个终端会话运行着。它们叫做虚拟终端或者是虚拟控制台。在大多数Linux发行版中，这些终端会话都可以通过按下`Ctrl-Alt-F1`到`Ctrl-Alt-F6`访问。当一个会话被访问的时候，它会显示登录提示框，我们需要输入用户名和密码。要从一个虚拟控制台转换到另一个，按下Alt和F1-F6（中的一个）。返回图形桌面，按下Alt-F7。

# 文件系统中跳转
## 理解文件系统树
类UNIX系统不像Windows，每个存储设备都有一个独自的文件系统。类Unix操作系统总是只有一个单一的文件系统树，不管有多少个磁盘或者存储设备连接到计算机上。根据负责维护系统安全的系统管理员的兴致，存储设备连接到（或者更精确些，是挂载到）目录树的各个节点上。
## 当前工作目录
pwd(print working directory) 显示当前工作目录。
当首次登录系统（或者启动终端仿真器会话）后，当前工作目录是我们的家目录。当用户以普通用户的身份操控系统时，家目录是唯一允许用户对文件进行写入的地方。
## 列出目录内容
用ls命令可以列出任一个目录的内容，而不只是当前工作目录的内容。
## 更改当前工作目录
输入cd，然后输入你想要去的工作目录的路径名。路径名可以通过两种方式来指定，一种是绝对路径，另一种是相对路径。
## 绝对路径
绝对路径开始于根目录，紧跟着目录树的一个个分支，一直达到所期望的目录或文件。
## 相对路径
相对路径开始于工作目录。为了做到这个，我们在文件系统中用一对特殊符号来表示相对位置。这对特殊符号是`.`和`..`
`.`指的是工作目录，`..`指的是工作目录的父目录。
可以省略`./`，即`cd bin`等效于`cd ./bin`
## 有用的快捷键
|快捷键 |运行结果 |
|:-:|:-:|
|cd |更改工作目录到你的家目录 |
|cd - |更改工作目录到先前的工作目录 |
|cd ~user_name |更改工作目录到用户家目录 |
## 关于文件名的重要规则
1. 以“.”字符开头的文件是隐藏文件。ls命令不能列出它们。用ls -a命令就可以了。
2. 文件名和命令名是大小写敏感的。文件名“File1”和“file1”是指两个不同的文件名。
3. Linux没有“文件扩展名”的概念
4. 虽然Linux支持长文件名，文件名可能包含标点符号，但标点符号仅限使用“.”，“-”，下划线。最重要的是，不要在文件名中使用空格。如想表示词与词间的空格，用下划线字符来替代。
# 探究操作系统
* ls 列出目录内容
* file 确定文件类型
* less 浏览文件内容

    除了当前工作目录以外，也可以指定要列出内容的目录，就像这样：
```
ls /usr
```
甚至可以列出多个指定目录的内容。如，列出用户家目录（用字符~代表）和/usr目录的内容：
```
ls ~ /usr
```
也可以改变输出格式，来得到更多的细节：如：使用ls命令的"-l"选项，则结果以
长模式输出。
## 选项和参数
大多数命令是如何工作的？ 命令名经常会带有一个或多个用来更正命令行为的选项，选项后会带有一个或多个参数，这些参数是命令作用的对象。大多数命令看起来像这样：
```
command -options arguments
```
大多数命令使用的选项，是由一个中划线加上一个字符组成，例如“-l”，
但许多命令，包括来自GNU项目的命令，也支持长选项，长选项由两个中划线加上一个字组成。当然，许多命令也允许把多个短选项串在一起使用。
下面这个例子，ls命令有两个选项，“l”选项产生长格式输出，“t”选项按文件修改时间的先后来排序。
```
ls -lt
```
加上长选项“--reverse”，则结果会以相反的顺序输出：
```
ls -lt --reverse
```
ls命令有大量选项：
|选项 |长选项 |描述 |
|:-:|:-:|:-:|
|-a |--all |列出所有文件，包括以圆点开头的默认会被隐藏的文件 |
|-d |--directory |把这个选项与-l选项结合使用，可以看到所指定目录的详细信息，而不是目录中的内容 |
|-F |--classify |在每个所列出的名字后面加上一个指示符。例如，如果名字是目录名，则会加上一个'/'字符。 |
|-h |--human-readable |当以长格式列出时，以人们可读的格式，而不是以字节数来显示文件的大小 |
|-l | |以长格式显示结果。 |
|-r |--reverse |以相反的顺序来显示结果。通常，ls命令的输出结果按照字母升序排列。 |
|-S | |命令输出结果按照文件大小来排序。 |
|-t | |按照修改时间来排序。 |


## 深入研究长格式输出
-l 选项导致ls的输出结果以长格式输出。这种格式包含大量有用信息。
来看下各个输出字段的含义：  

|字段 |含义 |
|:-:|:-:|
|-rw-r--r-- |对于文件的访问权限。第一个字符指明文件类型。在不同类型之间，开头的“-”说明是一个普通文件，“d”表明是一个目录。其后三个字符是文件所有者的访问权限，再其后三个字符是文件所属组中成员的访问权限，最后三个字符是其他所有人的访问权限 |
|1 |文件的硬链接数目 |
|root |文件属主的用户名 |
|root |文件所属用户组的名字 |
|32059 |以字节数表示的文件大小 |
|2007-04-03 11：05 |上次修改文件的时间和日期 |
|oo-cd-cover.odf |文件名 |

![image-20210930203140441](https://raw.githubusercontent.com/lunnche/picgo-image/main/202109302031479.png)



## 确定文件类型
```
file filename
```
当调用file命令后，file命令会打印出文件内容的简单描述。
类Unix操作系统中比如说Linux中，有个普遍观念就是“一切皆是文件”。

## 用less浏览文件内容
什么是“文本”
在计算机中，有许多方法可以表达信息。所有的方法都涉及到，在信息与一些数字之间确立一种关系，而这些数字可以用来代表信息。毕竟，计算机只能理解数字，这样所有的数据都被转换成数值来表示。
有些数值表达法非常复杂（例如压缩的视频文件），而其他的就相当简单。最早也是最简单的一种表达法，叫做ASCII文本。ASCII（发音是“As-Key"）是美国信息交换标准码的简称（American Standard Code for information Interchange），它首先被用在电传打字机上，用来实现键盘字符到数字的映射。
文本是简单的字符与数字之间的一对一映射。它非常紧凑。五十个字符的文本翻译成五十个字节的数据。文本只是包含简单的字符到数字的映射，理解这点很重要。它和一些文字处理器文档不一样，比如由微软和OpenOffice.org文档编辑器创建的文件。这些文件和简单的ASCII文件形成鲜明对比。它们包含许多非文本元素，来描述它的结构和格式。普通的ASCII文件，只包含字符本身，和一些基本的控制符，像制表符，回车符及换行符。

著名的NOTEPAD.EXE就是一个ASCII文本文件编辑器。

```
less filename
```
less程序最常使用的键盘命令

|命令 |行为 |
|:-:|:-:|
|Page UP or b |向上翻滚一页 |
|Page Down or space |向下翻滚一页 |
|UP Arrow |向上翻滚一行 |
|Down Arrow |向下翻滚一行 |
|G |移动到最后一行 |
|1G or g |移动到开头一行 |
|/charaters |向前查找指定字符串 |
|n |向前查找下一个出现的字符串，这个字符串是之前所指定查找的 |
|h |显示帮助屏幕 |
|q |退出less程序|


## less is more （禅语：色即是空）
less程序是早期Unix程序more的改进版。"less"这个名字，对习语“less is more”开了个玩笑，这个习语是现代主义建筑师和设计师的座右铭。
less属于“页面调度器”程序类，这些程序允许通过页方式，在一页中轻松地浏览长长的文本文档。more程序只能向前分页浏览，而less程序允许前后分页浏览，它还有很多其它特性。

## 旅行指南
Linux文件系统布局与类Unix系统的文件布局很相似。一个已经发布的标准，叫做 Linux Filesystem Hierarchy Standard (Linuxx文件系统层次标准)。大多数Linux发行版都根据这个标准。
使用Linux系统不要怕出错，普通用户是很难把东西弄乱的，那是系统管理员的工作。
如果一个命令抱怨一些事情，不要管它，尽管去玩别的东西。在系统里四处逛逛。下面列出了Linux系统中的目录。
|目录 |评论 |
|:-:|:-:|
|/ |根目录，万物起源 |
|/bin |包含系统启动和运行必须的二进制程序 |
| /boot| 包含Linux内核，最初的RMA磁盘映像（系统启动时，由驱动程序所需），和启动加载程序。有趣的文件: /boot/grub/grub.conf or menu.lst，被用来配置启动加载程序。/boot/vmlinuz,Linux内核|
|/dev | 这是一个包含设备结点的特殊目录。“一切都是文件”，也适用于设备。在这个目录里，内核维护着它支持的设备|
| /etc| 这个目录包含所有系统层面的配置文件。它也包含一些列的shell脚本，在系统启动时，这些脚本会运行每个系统服务。这个目录中的任何文件应该是可读的文本文件。一些有意思的文件：/etc/crontab，定义自动运行的任务。 /etc/fstab，包含存储设备的列表，以及与他们相关的挂载点。/etc/passwd，包含用户账号列表。|
| /home| 在通常的配置环境下，系统会在/home下，给每个用户分配一个目录。普通只能在他们自己的目录下创建文件。这个限制保护系统免受错误的用户活动破坏。|
| /lib| 包含核心系统程序所需的库文件。这些文件与Windows中的动态链接库相似。|
| /lost+found|每个使用Linux文件系统的格式化分区或设备，例如ext3文件系统，都会有这个目录。除非文件系统真正的损坏了，那么这个目录会是个空目录。 |
| /media| 在现在的Linux系统中，/media目录会包含可移除媒体设备的挂载点，例如USB驱动器，CD-ROMs等。这些设备连接到计算机之后，会自动地挂载到这个目录结点下。|
|/mnt |在早些的Linux系统中，/mnt目录包含可移除设备的挂载点。|
|/opt |这个/opt目录被用来安装“可选的”软件。这个主要用来存储可能安装在系统中的商业软件产品。|
|/proc |这个/proc目录很特殊。从存储在硬盘上的文件的意义上说，它不是真正的文件系统。反而，它是一个由Linux内核维护的虚拟文件系统。它所包含的文件是内核的窥视孔。这些文件是可读的，他们会告诉你内核是怎样监管计算机的。|
|/root |root账户的家目录。|
|/sbin |这个目录包含“系统”二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留。|
|/tmp | 这个/tmp 目录，是用来存储由各种程序创建的临时文件的<br/>地方。一些配置，导致系统每次重新启动时，都会清空这个<br/>目录。 |
|/usr | 在 Linux 系统中，/usr 目录可能是最大的一个。它包含普<br/>通用户所需要的所有程序和文件。 |
|/usr/bin | /usr/bin 目录包含系统安装的可执行程序。通常，这个目录<br/>会包含许多程序。 |
|/usr/lib | 包含由/usr/bin 目录中的程序所用的共享库。 |
|/usr/local | 这个/usr/local 目录，是非系统发行版自带，却打算让系统<br/>使用的程序的安装目录。通常，由源码编译的程序会安装<br/>在/usr/local/bin 目录下。新安装的 Linux 系统中，会存在<br/>这个目录，但却是空目录，直到系统管理员放些东西到它里<br/>面。 |
|/usr/sbin | 包含许多系统管理程序。 |
|/usr/share | /usr/share 目录包含许多由/usr/bin 目录中的程序使用的共<br/>享数据。其中包括像默认的配置文件，图标，桌面背景，音<br/>频文件等等。 |
|/usr/share/doc | 大多数安装在系统中的软件包会包含一些文档。在/usr/<br/>share/doc 目录下，我们可以找到按照软件包分类的文档。 |
|/var | 除了/tmp 和/home 目录之外，相对来说，目前我们看到的<br/>目录是静态的，这是说，它们的内容不会改变。/var 目录<br/>是可能需要改动的文件存储的地方。各种数据库，假脱机文<br/>件，用户邮件等等，都驻扎在这里。 |
|/var/log | 这个/var/log 目录包含日志文件，各种系统活动的记录。这<br/>些文件非常重要，并且应该时时监测它们。其中最重要的一<br/>个文件是/var/log/messages。注意，为了系统安全，在一些<br/>系统中，你必须是超级用户才能查看这些日志文件。 |

## 符号链接
可能会看到一个目录，列出像这样的一条信息：

![image-20211003174151000](https://raw.githubusercontent.com/lunnche/picgo-image/main/202110031741043.png)

为何这条信息第一个字符是“l”，并且有两个文件名呢？这是一个特殊文件，叫做
符号链接（也称为软链接或者 symlink ）。在大多数“类 Unix”系统中，有可能一个文件被多
个文件名所指向。  

适用于某文件经常随版本号更新经常改名，每次改名都需要跟踪每个可能使用了这个文件的程序，使用符号链接可以把多个文件名指向同一个文件。
## 硬链接

还有一种链接类型，叫做硬链接。硬链接同样允许文件有多个名字，但是硬链接以不同的方法来创建多个文件名。  

# 操作文件和目录
cp 复制文件和目录
mv 移动/重命名文件和目录
mkdir 创建目录
rm 删除文件和目录
ln 创建硬链接和符号链接

## 通配符

使用通配符（也以文件名代换著称）允许你依据字符类型来选择文件名。  

| 通配符        | 意义                               |
| ------------- | ---------------------------------- |
| \*            | 匹配任意多个字符（包括零个或一个） |
| ?             | 匹配任意一个字符（不包括零个）     |
| [characters]  | 匹配任意一个属于字符集中的字符     |
| [!characters] | 匹配任意一个不是字符集中的字符     |
| [[:class:]]   | 匹配任意一个属于指定字符类中的字符 |



| 字符类    | 意义                   |
| --------- | ---------------------- |
| [:alnum:] | 匹配任意一个字母或数字 |
| [:alpha:] | 匹配任意一个字母       |
| [:digit:] | 匹配任意一个数字       |
| [:lower:] | 匹配任意一个小写字母   |
| [:upper]  | 匹配任意一个大写字母   |

借助通配符，为文件名构建非常复杂的选择标准成为可能。  

| 模式                      | 匹配对象                                                     |
| ------------------------- | ------------------------------------------------------------ |
| *                         | 所有文件                                                     |
| g*                        | 文件名以“g”开头的文件                                        |
| b*.txt                    | 以”b” 开头，中间有零个或任意多个字符，并以”.txt” 结尾<br/>的文件 |
| Data???                   | 以“Data”开头，其后紧接着 3 个字符的文件                      |
| [abc]*                    | 文件名以”a”,”b”, 或”c” 开头的文件                            |
| `BACKUP.[0-9][0-9][0-9] ` | 以”BACKUP.” 开头，并紧接着 3 个数字的文件                    |
| [[:upper:]]*              | 以大写字母开头的文件                                         |
| [![:digit:]]*             | 不以数字开头的文件                                           |
| *[[:lower:]123]           | 文件名以小写字母结尾，或以“1”，“2”，或“3”结尾的<br/>文件     |

接受文件名作为参数的任何命令，都可以使用通配符  

字符范围  

 [A-Z] 或 [a-z] 形式的字符范围表示法。在早期的 Linux 版本中仍有效。虽然它们仍然起作用，但是你必须小心地使用它们，
因为它们不会产生你期望的输出结果，除非你合理地配置它们。从现在开始，你应该避免使用它们，并且用字符类来代替它们。  

通配符非常重要，不仅因为它们经常用在命令行中，而且一些图形文件管理器
也支持它们  

在 Nautilus (GNOME 文件管理器）中，可以通过 Edit/Select 模式菜单项来
选择文件。输入一个用通配符表示的文件选择模式后，那么当前所浏览的目录
中，所匹配的文件名就会高亮显示。

• 在 Dolphin 和 Konqueror（KDE 文件管理器）中，可以在地址栏中直接输入
通配符。例如，如果你想查看目录/usr/bin 中，所有以小写字母 ‘u’ 开头的文
件，在地址栏中敲入 ‘/usr/bin/u*‘，则文件管理器会显示匹配的结果。  

## mkdir
```
mkdir directory...
```

注意表示法: 在描述一个命令时（如上所示），当有三个圆点跟在一个命令的参数后面，这
意味着那个参数可以重复  即：

```
mkdir dir1 dir2 dir3
```

## cp-复制文件和目录

有两种使用方法：

```
cp item1 item2
```
复制单个文件或目录“item1"到文件或目录"item2"

```
cp item... directory
```
复制多个项目（文件或目录）到一个目录下。

## 有用的选项和实例

| 选项              | 意义                                                         |
| ----------------- | ------------------------------------------------------------ |
| -a, --archive     | 复制文件和目录，以及它们的属性，包括所有权和权限。通<br/>常，复本具有用户所操作文件的默认属性。 |
| -i, --interactive | 在重写已存在文件之前，提示用户确认。如果这个选项不指<br/>定， cp 命令会默认重写文件。 |
| -r, --recursive   | 递归地复制目录及目录中的内容。当复制目录时，需要这个<br/>选项（或者 -a 选项）。 |
| -u, --update      | 当把文件从一个目录复制到另一个目录时，仅复制目标目录<br/>中不存在的文件，或者是文件内容新于目标目录中已经存在<br/>的文件。 |
| -v, --verbose     | 显示翔实的命令操作信息                                       |

cp实例

| 命令                | 运行结果                                                     |
| ------------------- | ------------------------------------------------------------ |
| cp file1 file2      | 复制文件 file1 内容到文件 file2。如果 file2 已经存在， file2<br/>的内容会被 file1 的内容重写。如果 file2 不存在，则会创建<br/>file2。 |
| cp -i file1 file2   | 这条命令和上面的命令一样，除了如果文件 file2 存在的话，<br/>在文件 file2 被重写之前，会提示用户确认信息。 |
| cp file1 file2 dir1 | 复制文件 file1 和文件 file2 到目录 dir1。目录 dir1 必须存<br/>在。 |
| cp dir1/* dir2      | 使用一个通配符，在目录 dir1 中的所有文件都被复制到目<br/>录 dir2 中。 dir2 必须已经存在。 |
| cp -r dir1 dir2     | 复制目录 dir1 中的内容到目录 dir2。如果目录 dir2 不存在，<br/>创建目录 dir2，操作完成后，目录 dir2 中的内容和 dir1 中<br/>的一样。如果目录 dir2 存在，则目录 dir1 (和目录中的内<br/>容) 将会被复制到 dir2 中。 |

## mv-移动和重命名文件

```
mv item1 item2
```
这意思是把文件或目录"item1"移动或重命名为"item2"，或者：
```
mv item... ditectory
```
把一个或多个条目从一个目录移动到另一个目录中。
## 有用的选项和实例
| 选项 | 意义 |
|:-:|:-:|
| -i --interactive | 在重写一个已经存在的文件之前，提示用户确认信息。 如<br/>果不指定这个选项， mv 命令会默认重写文件内容。 |
| -u --update | 当把文件从一个目录移动另一个目录时，只是移动不存在的<br/>文件，或者文件内容新于目标目录相对应文件的内容。 |
| -v --verbose | 当操作 mv 命令时，显示翔实的操作信息。 |

| mv file1 file2 | 移动 file1 到 file2。如果 file2 存在，它的内容会被 file1 的<br/>内容重写。 如果 file2 不存在，则创建 file2。 每种情况下，<br/>file1 不再存在。 |
|:-:|:-:|
| mv -i file1 file2 | 除了如果 file2 存在的话，在 file2 被重写之前，用户会得到<br/>提示信息外，这个和上面的选项一样。 |
| mv file1 file2 dir1 | 移动 file1 和 file2 到目录 dir1 中。 dir1 必须已经存在。 |
| mv dir1 dir2 | 如果目录 dir2 不存在，创建目录 dir2，并且移动目录 dir1<br/>的内容到目录 dir2 中，同时删除目录 dir1。如果目录 dir2<br/>存在，移动目录 dir1（及它的内容）到目录 dir2。 |

## rm-删除文件和目录
```
rm item...
```
## 有用的选项和实例
| -i, --interactive | 在删除已存在的文件前，提示用户确认信息。 如果不指定<br/>这个选项， rm 会默默地删除文件 |
|:-:|:-:|
| -r, --recursive | 递归地删除文件，这意味着，如果要删除一个目录，而此目<br/>录又包含子目录，那么子目录也会被删除。要删除一个目<br/>录，必须指定这个选项。 |
| -f, --force | 忽视不存在的文件，不显示提示信息。这选项颠覆了“--<br/>interactive”选项。 |
| -v, --verbose | 在执行 rm 命令时，显示翔实的操作信息。 |

| 命令 | 运行结果 |
|:-:|:-:|
| rm file1 | 默默地删除文件 |
| rm -i file1 | 除了在删除文件之前，提示用户确认信息之外，和上面的命<br/>令作用一样。 |
| rm -r file1 dir1 | 删除文件 file1, 目录 dir1，及 dir1 中的内容。 |
| rm -rf file1 dir1 | 同上，除了如果文件 file1，或目录 dir1 不存在的话， rm 仍<br/>会继续执行 |

小心rm

类 Unix 的操作系统，比如说 Linux，没有复原命令。一旦你用 rm 删除了一些

东西，它就消失了。 Linux 假定你很聪明，你知道你在做什么。  

尤其要小心通配符。思考一下这个经典的例子。假如说，你只想删除一个目录
中的 HTML 文件。输入：
rm *.html  

这是正确的，如果你不小心在“*”和“.html”之间多输入了一个空格，就像这
样：
rm * .html  

这个 rm 命令会删除目录中的所有文件，还会抱怨没有文件叫做“.html”。  

小贴士。 无论什么时候， rm 命令用到通配符（除了仔细检查输入的内容外！），
用 ls 命令来测试通配符。这会让你看到要删除的文件列表。然后按下上箭头按键，
重新调用刚刚执行的命令，用 rm 替换 ls。  

## ln-创建链接
```
ln file link
```
创建硬链接
```
ln -s item link
```
创建符号链接，"item"可以是一个文件或是一个目录。

## 硬链接

硬链接和符号链接比起来，硬链接是最初 Unix 创建链接的方式，而符号链接更加现代。在
默认情况下，每个文件有一个硬链接，这个硬链接给文件起名字。当我们创建一个硬链接以后，
就为文件创建了一个额外的目录条目。硬链接有两个重要局限性：  

\1. 一个硬链接不能关联它所在文件系统之外的文件。这是说一个链接不能关联与链接本身
不在同一个磁盘分区上的文件。
\2. 一个硬链接不能关联一个目录。  

一个硬链接和文件本身没有什么区别。不像符号链接，当你列出一个包含硬链接的目录内
容时，你会看到没有特殊的链接指示说明。当一个硬链接被删除时，这个链接被删除，但是文
件本身的内容仍然存在（这是说，它所占的磁盘空间不会被重新分配），直到所有关联这个文
件的链接都删除掉。

## 符号链接

创建符号链接是为了克服硬链接的局限性。符号链接生效，是通过创建一个特殊类型的文
件，这个文件包含一个关联文件或目录的文本指针。在这一方面，它们和 Windows 的快捷方
式差不多，当然，符号链接早于 Windows 的快捷方式很多年;-)  

一个符号链接指向一个文件，而且这个符号链接本身与其它的符号链接几乎没有区别。例
如，如果你往一个符号链接里面写入东西，那么相关联的文件也被写入。然而，当你删除一个
符号链接时，只有这个链接被删除，而不是文件自身。如果先于符号链接删除文件，这个链接
仍然存在，但是不指向任何东西。在这种情况下，这个链接被称为坏链接。在许多实现中， ls
命令会以不同的颜色展示坏链接，比如说红色，来显示它们的存在。  

注意：
```
mv dir1 dir2
```
如果dir2已经存在，则把dir1移进dir2里面，若dir2不存在，把dir1改名为dir2。再把dir1原来内容放进去。

## 创建硬链接
一个文件至少有一个硬链接，因为文件名就是由链接创建的。
当考虑到硬。链接的时候，可以假设文件由两部分组成：包含文件内容的数据部分和持有文件名的名字部分。当我们创建文件硬链接的时候，实际上是为文件创建了额外的名字部分，并且这些名字都关系到相同的数据部分。这时系统会分配一连串的磁盘给所谓的索引节点，然后索引节点与文件名字部分相关联。。因此每一个硬链接都关系到一个具体的包含文件内容的索引节点。
ls命令有一种方法，来展示（文件索引节点）的信息。在命令中加上"-i"选项。
这个版本的列表中，第一字段表示文件索引节点号。
## 创建符号链接
建立符号链接的目的是为了客服硬链接的两个缺点：硬链接不能跨越物理设备，硬链接不能关联目录，只能是文件。符号链接是文件的特殊类型，它包含一个指向目标文件或目录的文本指针。

注意：
```
ln -s fun dir1/fun-sym
```
这样就会形成坏链接
应该是
```
ln -s ../fun dir1/fun-sym
```
我猜 之所以加点点是因为 fun是在dir1的父目录里面 我猜的

```
[me@linuxbox playground]$ ls -l dir1
total 4
-rw-r--r-- 4 me me 1650 2008-01-10 16:33 fun-hard
lrwxrwxrwx 1 me me
6 2008-01-15 15:17 fun-sym -> ../fun
```

目录 dir1 中，fun-sym 的列表说明了它是一个符号链接，通过在第一字段中的首字符 “l”
可知，并且它还指向 “../fun”，也是正确的。相对于 fun-sym 的存储位置，fun 在它的上一个目录。同时注意，符号链接文件的长度是 6，这是字符串 “../fun” 所包含的字符数，而不是符号链接所指向的文件长度。
建立符号链接，既可以使用绝对路径名，也可以使用相对路径名。相对路径名更令人满意，因为它允许一个包含符号链接的目录重命名或移动，而不会破坏链接。
除了普通文件，符号链接也能关联目录
## 移动发文件和目录
删除一个文件 则它的符号链接指向已经不存在的文件，链接已经坏了
大多数Linux发行版配置ls显示损坏的链接。在Fedora系统中，坏的链接以闪烁的红色文本显示!损坏链接的出现，并不危险，但是相当混乱。
对于符号链接，执行的大多数文件操作是针对链接的对象，而不是链接本身。而rm命令是个特例。当你删除链接的时候，删除链接本身，而不是链接的对象。
删除文件夹，需要在rm后加上-r
> 用GUI创建符号链接  
> 文件管理器GNOME和KDE都提供了一个简单而自动化的方法来创建符号链接。  
> 在GNOME里，当拖动文件时，同时按下Ctrl＋Shift按键会创建一个链接，而不是复制（或移动）文件。在KDE中，无论什么时候放下一个文件，会弹出一个小菜单，这个菜单会提供复制，移动，或创建链接文件选项。  


## 使用命令
### 什么是命令
命令可以是下面四中形式之一：
1. 是一个可执行程序，如同目录/usr/bin中的文件一样。属于这一类的程序，可以编译成二进制文件，诸如用C和C＋＋语言写的程序，也可以是由脚本语言写成的程序，比如说shell,perl,python,ruby，等等。
2. 是一个内建于shell自身的命令。bash支持若干命令，内部叫做shell内部命令（builtins）。例如，cd命令，就是一个shell内部命令。
3. 是一个shell函数。这些是小规模的shell脚本，它们混合到环境变量中。
4. 是一个命令别名。可以定义自己的命令，建立在其它命令之上。

## 识别命令
能确切地知道正在使用四类命令中的哪一类经常很有用。Linux提供了方法来弄明白命令类型。

## type-显示命令的类型
type是shell内部命令，它会显示命令的类别，给出一个特定的命令名（做为参数）。它像这样工作：
```
type command
```
一些例子：
```
$ type type
type is a shell builtins
$ type ls
ls is aliased to 'ls --color=tty'
$ type cp
cp is /bin/cp
```
注意：ls命令实际上是ls命令加上选项“--color=auto”的别名。这也是为什么ls的输出结果是有颜色的。

## which——显示一个可执行程序的位置
有时候在一个操作系统中，不只安装了可执行程序的一个版本。然后在桌面系统中，这并不普遍，但在大型服务器中，却很平常。为了确定所给定的执行程序的准确位置，使用which命令:
```
$ which ls
/bin/ls
```
这个命令只对可执行程序有效，不包括内部命令和命令别名，别名是真正的可执行程序的替代物。当试着使用shell内部命令时，或者得不到回应，或者是个错误信息。
## 得到命令文档
### help-得到shell内部命令的帮助文档
```
$ help cd
cd: cd [-L|-P] [dir]
Change...
```
注意表示法:出现在命令语法说明中的方括号，表示可选的项目。一个竖杠字符表示互斥选项。在上面cd命令的例子中，cd命令可能有一个“-L”选项或者“-P”选项，进一步，可能有参数“dir”。
## --help - 显示用法信息
许多可执行程序支持一个--help选项，这个选项是显示命令所支持的语法和选项说明。例如：
```
$ mkdir --help
Usage: mkdir  [OPTION] DIRECTORY...
Create ...
```

## man -显示程序手册页
许多希望被命令行使用的可执行程序，提供了一个正式的文档，叫做手册或手册页。一个特殊的叫做man的分页程序，可用来浏览它们。
```
man program
```
手册文档一般包含一个标题，命令语法的纲要，命令用途的说明，和命令选项列表，及每个选项的说明。但通常手册文档不包含实例。
```
$ man ls
```
在大多数Linux系统中，man使用less工具来显示参考手册，所以当浏览文档时，less命令都能有效。
man所显示的参考手册，被分成了几个章节，它们不仅仅包括用户命令，也包括系统管理员命令，程序接口，文件格式等。
|章节 |内容 |
|:-:|:-:|
|1 |用户命令 |
|2 |程序接口内核系统调用 |
|3 |C库函数程序接口 |
|4 |特殊文件，比如说设备结点和驱动程序 |
|5 |文件格式 |
|6 |游戏娱乐，如屏幕保护程序 |
|7 |其他方面 |
|8 |系统管理员命令 |



