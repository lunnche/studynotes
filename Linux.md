# Ubuntu 20.04 LTS 安装

Ubuntu 20.04 LTS 代号 Focal Fossa，于 2020 年 4 月 23 日正式发布，Ubuntu 20.04 LTS 附带 Kernel 5.4、GNOME 3.36、ZFS 安装支持更快的启动速度、GameMode 性能工具、Snap Store（用于替代 Ubuntu Software）。Ubuntu 20.04 LTS 的支持周期长达 5 年，同时适用于 Ubuntu Desktop、Ubuntu Server、Ubuntu Cloud 和 Ubuntu Core，其安全和维护更新直到 2025 年 4 月才到期。其余 flavour 的支持也长达 3 年。

背后有一个公司在支持，稳定性最好的Linux版本之一，可用来做server，manjaro运维团队人少，大部分新手，做服务器不稳定。

## 准备工作

Ubuntu有LTS版本和“技术前沿版”，这两种版本都可以作为日常的桌面终端进行使用，但通常我们会认为LTS版本更加稳定，而且可以获得至发行之日起为期5年的技术支持。而LTS版本之间发行的所谓“技术前沿版”仅有9个月的支持周期，到期之后用户就必需升级到新的版本下。

再有就是32位和64位版本选择的问题。之前有一个比较流行的说法是内存小于3GB时就不要选择64位版本进行安装，其实这种说法可以忽略不计，64位可以更加充分的利用CPU支持，哪怕你的内存小于3GB。

选择一个8g或以上容量的U盘，推荐USB3.0接口，速度快。

对U盘格式化。

用Rufus或Universal USB Installer等刻录软件制作启动U盘。

为Ubuntu腾出40G以上硬盘空间：在桌面右击`计算机`,选择`管理`，点击左侧`磁盘管理`，在你的机械硬盘或固态硬盘上分出一个大于40G的空间（如果你只是体验的话，只需要20G不到就好了）。具体为右击你要分区的磁盘，选择`压缩卷`，填入你要压缩的空间大小。

BIOS关闭Secure Boot：以联想电脑为例， 重启电脑，一直狂戳`F2`(有的电脑是F1，有的电脑是`Esc`,自行查询)，直到进入BIOS，点击方向箭头→ 移动到Security，再按↓移动到Secure Boot上，点击`回车键`，选择`Disable`，去Boot里面看看USB Boot是否为Enabled。

> **关于无法读出硬盘**（一般不用管）
>
> 需要在BIOS中将SATA Controller Mode选为ACHI模式，最后，按`F10`保存退出。
>  （更新）这里有个问题，改完SATA  Controller Mode装完Ubuntu后无法进入Windows的解决方案是改完进入Windows的安全模式，然后重启就正常了

退出BIOS后，保持U盘不拔下来，狂戳`F12`（不同电脑可能不同）,在出现的界面选择你的U盘。

## 从U盘安装

1 单击“安装Ubuntu”

2 选择键盘布局 Chinese-Chinese

3 有 2 种安装模式可供选择：

- **正常安装** 安装功能强大的桌面所需的所有应用程序，包括：Web 浏览器、办公套件、游戏和媒体播放器等。
- **最小安装** 安装最小的桌面版本，该版本仅具有 Web 浏览器和一些基本实用程序。

可以在安装 Ubuntu 20.04 LTS 桌面版的同时勾选「安装 Ubuntu 时下载更新」选项以下载并应用更新，也可以选择是否同时（推荐选上）「为图形或无线硬件，以及其它媒体格式安装第三方软件」。

4 如果当前计算机没有操作系统，则安装程序将提供以下两个选项：

- 清除整个磁盘并安装 Ubuntu

  此选项将删除磁盘中的所有内容，还有一个称为「Advanced Features」（高级功能）的附加选项，让您可以有如下 3 个附加选项。

  - 在 Ubuntu 新安装中使用 ZFS
  - （可选）加密 Ubuntu 新安装以提高安全性
  - EXPERIMENTAL – 擦除磁盘并使用ZFS

- **其它选项** 此选项允许手动对硬盘进行分区，可以为每个分区设置自定义大小，选择使用 Windows 和/或其他操作系统进行双重引导。

不想写了 瞎装吧 能用就行 费那劲

# Linux
# shell

一说到命令行，我们真正指的是shell。shell就是一个程序，它接受从键盘输入的命令，然后把命令传递给操作系统去执行。几乎所有的Linux发行版都提供一个名为bash的来自GNU项目的shell程序。"bash"是"Bourne Again SHell"的首字母缩写，所指的是这样一个事实，bash是最初Unix上由Steve Bourne写成shell程序sh的增强版。

## 终端仿真器
当使用图形用户界面时，我们需要另一个和shell交互的叫做终端仿真器的程序。如果浏览下桌面菜单，可能会找到一个。虽然在菜单里它可能都被简单地称为"terminal"，但是KDE用的是konsole，而GNOME则使用gnome-terminal。还有其他一些终端仿真器可供Linux使用，但基本上它们都完成同样的事情，让我们能访问shell。

`$`叫做shell提示符，无论何时shell准备好去接受输入时，它就会出现。
它通常包括你的用户名@主机名，紧接着当前工作目录和一个美元符号。
如果提示符的最后一个字符是“#”，而不是“\$”，那么这个终端会话就有超级用户（管理员）权限。这意味我们或者是以root用户的身份登录，或者是我们选择的终端仿真器提供超级用户（管理员）权限。
## 命令历史
按下 上箭头，上次输入的命令会复现，这叫命令历史。许多Linux发行版默认保存最后输入的500个命令。按下 下箭头，先前输入的命令就消失了。
## 鼠标和光标
可以在终端仿真器里使用鼠标。X窗口系统（使GUI工作的底层引擎）内建了一种机制，支持快速拷贝和粘贴技巧。按下鼠标左键，沿着文本拖动鼠标（或者双击一个单词）高亮了一些文本，那么这些高亮的文本就拷贝到了一个由X管理的缓冲区里面。然后按下鼠标中键，这些文本就被粘贴到光标所在的位置
注意：不要再一个终端窗口里使用`Ctrl-c`和`Ctrl-v`快捷键来执行拷贝和粘贴操作。它们不起作用。对于shell来说，这两个控制代码有着不同的含义，它们在早于Microsoft Windows（定义复制粘贴的含义）许多年之前就赋予了不同的意义。
你的图形桌面环境（像KDE或GNOME），努力想和Windows一样，可能会把它的聚焦策略设置成“单击聚焦”。这意味着，为了让窗口聚焦（变成活动窗口）你需要单击它。这与“聚焦跟随鼠标”的传统X行为不同，传统X行为是指只要把鼠标移动到一个窗口上方。它能接受输入，但是直到你单击窗口之前它都不会称为前段窗口。设置聚焦策略为“聚焦跟随着鼠标”，可以使拷贝和粘贴更方便易用。可以在窗口管理器的配置程序中找到这个设置。
## 试试运行一些简单命令
date 显示系统当前时间和日期
cal 显示当前月份的日历
df 查看磁盘剩余空间的数量
free 显示空闲内存数量
exit 结束终端会话

## 幕后控制台
即使终端仿真器没有运行，在后台仍然有几个终端会话运行着。它们叫做虚拟终端或者是虚拟控制台。在大多数Linux发行版中，这些终端会话都可以通过按下`Ctrl-Alt-F1`到`Ctrl-Alt-F6`访问。当一个会话被访问的时候，它会显示登录提示框，我们需要输入用户名和密码。要从一个虚拟控制台转换到另一个，按下Alt和F1-F6（中的一个）。返回图形桌面，按下Alt-F7。

# 文件系统中跳转
## 理解文件系统树
类UNIX系统不像Windows，每个存储设备都有一个独自的文件系统。类Unix操作系统总是只有一个单一的文件系统树，不管有多少个磁盘或者存储设备连接到计算机上。根据负责维护系统安全的系统管理员的兴致，存储设备连接到（或者更精确些，是挂载到）目录树的各个节点上。
## 当前工作目录
pwd(print working directory) 显示当前工作目录。
当首次登录系统（或者启动终端仿真器会话）后，当前工作目录是我们的家目录。当用户以普通用户的身份操控系统时，家目录是唯一允许用户对文件进行写入的地方。
## 列出目录内容
用ls命令可以列出任一个目录的内容，而不只是当前工作目录的内容。
## 更改当前工作目录
输入cd，然后输入你想要去的工作目录的路径名。路径名可以通过两种方式来指定，一种是绝对路径，另一种是相对路径。
## 绝对路径
绝对路径开始于根目录，紧跟着目录树的一个个分支，一直达到所期望的目录或文件。
## 相对路径
相对路径开始于工作目录。为了做到这个，我们在文件系统中用一对特殊符号来表示相对位置。这对特殊符号是`.`和`..`
`.`指的是工作目录，`..`指的是工作目录的父目录。
可以省略`./`，即`cd bin`等效于`cd ./bin`
## 有用的快捷键
|快捷键 |运行结果 |
|:-:|:-:|
|cd |更改工作目录到你的家目录 |
|cd - |更改工作目录到先前的工作目录 |
|cd ~user_name |更改工作目录到用户家目录 |
## 关于文件名的重要规则
1. 以“.”字符开头的文件是隐藏文件。ls命令不能列出它们。用ls -a命令就可以了。
2. 文件名和命令名是大小写敏感的。文件名“File1”和“file1”是指两个不同的文件名。
3. Linux没有“文件扩展名”的概念
4. 虽然Linux支持长文件名，文件名可能包含标点符号，但标点符号仅限使用“.”，“-”，下划线。最重要的是，不要在文件名中使用空格。如想表示词与词间的空格，用下划线字符来替代。
# 探究操作系统
* ls 列出目录内容
* file 确定文件类型
* less 浏览文件内容

    除了当前工作目录以外，也可以指定要列出内容的目录，就像这样：
```
ls /usr
```
甚至可以列出多个指定目录的内容。如，列出用户家目录（用字符~代表）和/usr目录的内容：
```
ls ~ /usr
```
也可以改变输出格式，来得到更多的细节：如：使用ls命令的"-l"选项，则结果以
长模式输出。
## 选项和参数
大多数命令是如何工作的？ 命令名经常会带有一个或多个用来更正命令行为的选项，选项后会带有一个或多个参数，这些参数是命令作用的对象。大多数命令看起来像这样：
```
command -options arguments
```
大多数命令使用的选项，是由一个中划线加上一个字符组成，例如“-l”，
但许多命令，包括来自GNU项目的命令，也支持长选项，长选项由两个中划线加上一个字组成。当然，许多命令也允许把多个短选项串在一起使用。
下面这个例子，ls命令有两个选项，“l”选项产生长格式输出，“t”选项按文件修改时间的先后来排序。
```
ls -lt
```
加上长选项“--reverse”，则结果会以相反的顺序输出：
```
ls -lt --reverse
```
ls命令有大量选项：
|选项 |长选项 |描述 |
|:-:|:-:|:-:|
|-a |--all |列出所有文件，包括以圆点开头的默认会被隐藏的文件 |
|-d |--directory |把这个选项与-l选项结合使用，可以看到所指定目录的详细信息，而不是目录中的内容 |
|-F |--classify |在每个所列出的名字后面加上一个指示符。例如，如果名字是目录名，则会加上一个'/'字符。 |
|-h |--human-readable |当以长格式列出时，以人们可读的格式，而不是以字节数来显示文件的大小 |
|-l | |以长格式显示结果。 |
|-r |--reverse |以相反的顺序来显示结果。通常，ls命令的输出结果按照字母升序排列。 |
|-S | |命令输出结果按照文件大小来排序。 |
|-t | |按照修改时间来排序。 |


## 深入研究长格式输出
-l 选项导致ls的输出结果以长格式输出。这种格式包含大量有用信息。
来看下各个输出字段的含义：  

|字段 |含义 |
|:-:|:-:|
|-rw-r--r-- |对于文件的访问权限。第一个字符指明文件类型。在不同类型之间，开头的“-”说明是一个普通文件，“d”表明是一个目录。其后三个字符是文件所有者的访问权限，再其后三个字符是文件所属组中成员的访问权限，最后三个字符是其他所有人的访问权限 |
|1 |文件的硬链接数目 |
|root |文件属主的用户名 |
|root |文件所属用户组的名字 |
|32059 |以字节数表示的文件大小 |
|2007-04-03 11：05 |上次修改文件的时间和日期 |
|oo-cd-cover.odf |文件名 |

![image-20210930203140441](https://raw.githubusercontent.com/lunnche/picgo-image/main/202109302031479.png)



## 确定文件类型
```
file filename
```
当调用file命令后，file命令会打印出文件内容的简单描述。
类Unix操作系统中比如说Linux中，有个普遍观念就是“一切皆是文件”。

## 用less浏览文件内容
什么是“文本”
在计算机中，有许多方法可以表达信息。所有的方法都涉及到，在信息与一些数字之间确立一种关系，而这些数字可以用来代表信息。毕竟，计算机只能理解数字，这样所有的数据都被转换成数值来表示。
有些数值表达法非常复杂（例如压缩的视频文件），而其他的就相当简单。最早也是最简单的一种表达法，叫做ASCII文本。ASCII（发音是“As-Key"）是美国信息交换标准码的简称（American Standard Code for information Interchange），它首先被用在电传打字机上，用来实现键盘字符到数字的映射。
文本是简单的字符与数字之间的一对一映射。它非常紧凑。五十个字符的文本翻译成五十个字节的数据。文本只是包含简单的字符到数字的映射，理解这点很重要。它和一些文字处理器文档不一样，比如由微软和OpenOffice.org文档编辑器创建的文件。这些文件和简单的ASCII文件形成鲜明对比。它们包含许多非文本元素，来描述它的结构和格式。普通的ASCII文件，只包含字符本身，和一些基本的控制符，像制表符，回车符及换行符。

著名的NOTEPAD.EXE就是一个ASCII文本文件编辑器。

```
less filename
```
less程序最常使用的键盘命令

|命令 |行为 |
|:-:|:-:|
|Page UP or b |向上翻滚一页 |
|Page Down or space |向下翻滚一页 |
|UP Arrow |向上翻滚一行 |
|Down Arrow |向下翻滚一行 |
|G |移动到最后一行 |
|1G or g |移动到开头一行 |
|/charaters |向前查找指定字符串 |
|n |向前查找下一个出现的字符串，这个字符串是之前所指定查找的 |
|h |显示帮助屏幕 |
|q |退出less程序|


## less is more （禅语：色即是空）
less程序是早期Unix程序more的改进版。"less"这个名字，对习语“less is more”开了个玩笑，这个习语是现代主义建筑师和设计师的座右铭。
less属于“页面调度器”程序类，这些程序允许通过页方式，在一页中轻松地浏览长长的文本文档。more程序只能向前分页浏览，而less程序允许前后分页浏览，它还有很多其它特性。

## 旅行指南
Linux文件系统布局与类Unix系统的文件布局很相似。一个已经发布的标准，叫做 Linux Filesystem Hierarchy Standard (Linuxx文件系统层次标准)。大多数Linux发行版都根据这个标准。
使用Linux系统不要怕出错，普通用户是很难把东西弄乱的，那是系统管理员的工作。
如果一个命令抱怨一些事情，不要管它，尽管去玩别的东西。在系统里四处逛逛。下面列出了Linux系统中的目录。
|目录 |评论 |
|:-:|:-:|
|/ |根目录，万物起源 |
|/bin |包含系统启动和运行必须的二进制程序 |
| /boot| 包含Linux内核，最初的RMA磁盘映像（系统启动时，由驱动程序所需），和启动加载程序。有趣的文件: /boot/grub/grub.conf or menu.lst，被用来配置启动加载程序。/boot/vmlinuz,Linux内核|
|/dev | 这是一个包含设备结点的特殊目录。“一切都是文件”，也适用于设备。在这个目录里，内核维护着它支持的设备|
| /etc| 这个目录包含所有系统层面的配置文件。它也包含一些列的shell脚本，在系统启动时，这些脚本会运行每个系统服务。这个目录中的任何文件应该是可读的文本文件。一些有意思的文件：/etc/crontab，定义自动运行的任务。 /etc/fstab，包含存储设备的列表，以及与他们相关的挂载点。/etc/passwd，包含用户账号列表。|
| /home| 在通常的配置环境下，系统会在/home下，给每个用户分配一个目录。普通只能在他们自己的目录下创建文件。这个限制保护系统免受错误的用户活动破坏。|
| /lib| 包含核心系统程序所需的库文件。这些文件与Windows中的动态链接库相似。|
| /lost+found|每个使用Linux文件系统的格式化分区或设备，例如ext3文件系统，都会有这个目录。除非文件系统真正的损坏了，那么这个目录会是个空目录。 |
| /media| 在现在的Linux系统中，/media目录会包含可移除媒体设备的挂载点，例如USB驱动器，CD-ROMs等。这些设备连接到计算机之后，会自动地挂载到这个目录结点下。|
|/mnt |在早些的Linux系统中，/mnt目录包含可移除设备的挂载点。|
|/opt |这个/opt目录被用来安装“可选的”软件。这个主要用来存储可能安装在系统中的商业软件产品。|
|/proc |这个/proc目录很特殊。从存储在硬盘上的文件的意义上说，它不是真正的文件系统。反而，它是一个由Linux内核维护的虚拟文件系统。它所包含的文件是内核的窥视孔。这些文件是可读的，他们会告诉你内核是怎样监管计算机的。|
|/root |root账户的家目录。|
|/sbin |这个目录包含“系统”二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留。|
|/tmp | 这个/tmp 目录，是用来存储由各种程序创建的临时文件的<br/>地方。一些配置，导致系统每次重新启动时，都会清空这个<br/>目录。 |
|/usr | 在 Linux 系统中，/usr 目录可能是最大的一个。它包含普<br/>通用户所需要的所有程序和文件。 |
|/usr/bin | /usr/bin 目录包含系统安装的可执行程序。通常，这个目录<br/>会包含许多程序。 |
|/usr/lib | 包含由/usr/bin 目录中的程序所用的共享库。 |
|/usr/local | 这个/usr/local 目录，是非系统发行版自带，却打算让系统<br/>使用的程序的安装目录。通常，由源码编译的程序会安装<br/>在/usr/local/bin 目录下。新安装的 Linux 系统中，会存在<br/>这个目录，但却是空目录，直到系统管理员放些东西到它里<br/>面。 |
|/usr/sbin | 包含许多系统管理程序。 |
|/usr/share | /usr/share 目录包含许多由/usr/bin 目录中的程序使用的共<br/>享数据。其中包括像默认的配置文件，图标，桌面背景，音<br/>频文件等等。 |
|/usr/share/doc | 大多数安装在系统中的软件包会包含一些文档。在/usr/<br/>share/doc 目录下，我们可以找到按照软件包分类的文档。 |
|/var | 除了/tmp 和/home 目录之外，相对来说，目前我们看到的<br/>目录是静态的，这是说，它们的内容不会改变。/var 目录<br/>是可能需要改动的文件存储的地方。各种数据库，假脱机文<br/>件，用户邮件等等，都驻扎在这里。 |
|/var/log | 这个/var/log 目录包含日志文件，各种系统活动的记录。这<br/>些文件非常重要，并且应该时时监测它们。其中最重要的一<br/>个文件是/var/log/messages。注意，为了系统安全，在一些<br/>系统中，你必须是超级用户才能查看这些日志文件。 |

## 符号链接
可能会看到一个目录，列出像这样的一条信息：

![image-20211003174151000](https://raw.githubusercontent.com/lunnche/picgo-image/main/202110031741043.png)

为何这条信息第一个字符是“l”，并且有两个文件名呢？这是一个特殊文件，叫做
符号链接（也称为软链接或者 symlink ）。在大多数“类 Unix”系统中，有可能一个文件被多
个文件名所指向。  

适用于某文件经常随版本号更新经常改名，每次改名都需要跟踪每个可能使用了这个文件的程序，使用符号链接可以把多个文件名指向同一个文件。
## 硬链接

还有一种链接类型，叫做硬链接。硬链接同样允许文件有多个名字，但是硬链接以不同的方法来创建多个文件名。  

# 操作文件和目录
cp 复制文件和目录
mv 移动/重命名文件和目录
mkdir 创建目录
rm 删除文件和目录
ln 创建硬链接和符号链接

## 通配符

使用通配符（也以文件名代换著称）允许你依据字符类型来选择文件名。  

| 通配符        | 意义                               |
| ------------- | ---------------------------------- |
| \*            | 匹配任意多个字符（包括零个或一个） |
| ?             | 匹配任意一个字符（不包括零个）     |
| [characters]  | 匹配任意一个属于字符集中的字符     |
| [!characters] | 匹配任意一个不是字符集中的字符     |
| [[:class:]]   | 匹配任意一个属于指定字符类中的字符 |



| 字符类    | 意义                   |
| --------- | ---------------------- |
| [:alnum:] | 匹配任意一个字母或数字 |
| [:alpha:] | 匹配任意一个字母       |
| [:digit:] | 匹配任意一个数字       |
| [:lower:] | 匹配任意一个小写字母   |
| [:upper]  | 匹配任意一个大写字母   |

借助通配符，为文件名构建非常复杂的选择标准成为可能。  

| 模式                      | 匹配对象                                                     |
| ------------------------- | ------------------------------------------------------------ |
| *                         | 所有文件                                                     |
| g*                        | 文件名以“g”开头的文件                                        |
| b*.txt                    | 以”b” 开头，中间有零个或任意多个字符，并以”.txt” 结尾<br/>的文件 |
| Data???                   | 以“Data”开头，其后紧接着 3 个字符的文件                      |
| [abc]*                    | 文件名以”a”,”b”, 或”c” 开头的文件                            |
| `BACKUP.[0-9][0-9][0-9] ` | 以”BACKUP.” 开头，并紧接着 3 个数字的文件                    |
| [[:upper:]]*              | 以大写字母开头的文件                                         |
| [![:digit:]]*             | 不以数字开头的文件                                           |
| *[[:lower:]123]           | 文件名以小写字母结尾，或以“1”，“2”，或“3”结尾的<br/>文件     |

接受文件名作为参数的任何命令，都可以使用通配符  

字符范围  

 [A-Z] 或 [a-z] 形式的字符范围表示法。在早期的 Linux 版本中仍有效。虽然它们仍然起作用，但是你必须小心地使用它们，
因为它们不会产生你期望的输出结果，除非你合理地配置它们。从现在开始，你应该避免使用它们，并且用字符类来代替它们。  

通配符非常重要，不仅因为它们经常用在命令行中，而且一些图形文件管理器
也支持它们  

在 Nautilus (GNOME 文件管理器）中，可以通过 Edit/Select 模式菜单项来
选择文件。输入一个用通配符表示的文件选择模式后，那么当前所浏览的目录
中，所匹配的文件名就会高亮显示。

• 在 Dolphin 和 Konqueror（KDE 文件管理器）中，可以在地址栏中直接输入
通配符。例如，如果你想查看目录/usr/bin 中，所有以小写字母 ‘u’ 开头的文
件，在地址栏中敲入 ‘/usr/bin/u*‘，则文件管理器会显示匹配的结果。  

## mkdir
```
mkdir directory...
```

注意表示法: 在描述一个命令时（如上所示），当有三个圆点跟在一个命令的参数后面，这
意味着那个参数可以重复  即：

```
mkdir dir1 dir2 dir3
```

## cp-复制文件和目录

有两种使用方法：

```
cp item1 item2
```
复制单个文件或目录“item1"到文件或目录"item2"

```
cp item... directory
```
复制多个项目（文件或目录）到一个目录下。

## 有用的选项和实例

| 选项              | 意义                                                         |
| ----------------- | ------------------------------------------------------------ |
| -a, --archive     | 复制文件和目录，以及它们的属性，包括所有权和权限。通<br/>常，复本具有用户所操作文件的默认属性。 |
| -i, --interactive | 在重写已存在文件之前，提示用户确认。如果这个选项不指<br/>定， cp 命令会默认重写文件。 |
| -r, --recursive   | 递归地复制目录及目录中的内容。当复制目录时，需要这个<br/>选项（或者 -a 选项）。 |
| -u, --update      | 当把文件从一个目录复制到另一个目录时，仅复制目标目录<br/>中不存在的文件，或者是文件内容新于目标目录中已经存在<br/>的文件。 |
| -v, --verbose     | 显示翔实的命令操作信息                                       |

cp实例

| 命令                | 运行结果                                                     |
| ------------------- | ------------------------------------------------------------ |
| cp file1 file2      | 复制文件 file1 内容到文件 file2。如果 file2 已经存在， file2<br/>的内容会被 file1 的内容重写。如果 file2 不存在，则会创建<br/>file2。 |
| cp -i file1 file2   | 这条命令和上面的命令一样，除了如果文件 file2 存在的话，<br/>在文件 file2 被重写之前，会提示用户确认信息。 |
| cp file1 file2 dir1 | 复制文件 file1 和文件 file2 到目录 dir1。目录 dir1 必须存<br/>在。 |
| cp dir1/* dir2      | 使用一个通配符，在目录 dir1 中的所有文件都被复制到目<br/>录 dir2 中。 dir2 必须已经存在。 |
| cp -r dir1 dir2     | 复制目录 dir1 中的内容到目录 dir2。如果目录 dir2 不存在，<br/>创建目录 dir2，操作完成后，目录 dir2 中的内容和 dir1 中<br/>的一样。如果目录 dir2 存在，则目录 dir1 (和目录中的内<br/>容) 将会被复制到 dir2 中。 |

## mv-移动和重命名文件

```
mv item1 item2
```
这意思是把文件或目录"item1"移动或重命名为"item2"，或者：
```
mv item... ditectory
```
把一个或多个条目从一个目录移动到另一个目录中。
## 有用的选项和实例
| 选项 | 意义 |
|:-:|:-:|
| -i --interactive | 在重写一个已经存在的文件之前，提示用户确认信息。 如<br/>果不指定这个选项， mv 命令会默认重写文件内容。 |
| -u --update | 当把文件从一个目录移动另一个目录时，只是移动不存在的<br/>文件，或者文件内容新于目标目录相对应文件的内容。 |
| -v --verbose | 当操作 mv 命令时，显示翔实的操作信息。 |

| mv file1 file2 | 移动 file1 到 file2。如果 file2 存在，它的内容会被 file1 的<br/>内容重写。 如果 file2 不存在，则创建 file2。 每种情况下，<br/>file1 不再存在。 |
|:-:|:-:|
| mv -i file1 file2 | 除了如果 file2 存在的话，在 file2 被重写之前，用户会得到<br/>提示信息外，这个和上面的选项一样。 |
| mv file1 file2 dir1 | 移动 file1 和 file2 到目录 dir1 中。 dir1 必须已经存在。 |
| mv dir1 dir2 | 如果目录 dir2 不存在，创建目录 dir2，并且移动目录 dir1<br/>的内容到目录 dir2 中，同时删除目录 dir1。如果目录 dir2<br/>存在，移动目录 dir1（及它的内容）到目录 dir2。 |

## rm-删除文件和目录
```
rm item...
```
## 有用的选项和实例
| -i, --interactive | 在删除已存在的文件前，提示用户确认信息。 如果不指定<br/>这个选项， rm 会默默地删除文件 |
|:-:|:-:|
| -r, --recursive | 递归地删除文件，这意味着，如果要删除一个目录，而此目<br/>录又包含子目录，那么子目录也会被删除。要删除一个目<br/>录，必须指定这个选项。 |
| -f, --force | 忽视不存在的文件，不显示提示信息。这选项颠覆了“--<br/>interactive”选项。 |
| -v, --verbose | 在执行 rm 命令时，显示翔实的操作信息。 |

| 命令 | 运行结果 |
|:-:|:-:|
| rm file1 | 默默地删除文件 |
| rm -i file1 | 除了在删除文件之前，提示用户确认信息之外，和上面的命<br/>令作用一样。 |
| rm -r file1 dir1 | 删除文件 file1, 目录 dir1，及 dir1 中的内容。 |
| rm -rf file1 dir1 | 同上，除了如果文件 file1，或目录 dir1 不存在的话， rm 仍<br/>会继续执行 |

小心rm

类 Unix 的操作系统，比如说 Linux，没有复原命令。一旦你用 rm 删除了一些

东西，它就消失了。 Linux 假定你很聪明，你知道你在做什么。  

尤其要小心通配符。思考一下这个经典的例子。假如说，你只想删除一个目录
中的 HTML 文件。输入：
rm *.html  

这是正确的，如果你不小心在“*”和“.html”之间多输入了一个空格，就像这
样：
rm * .html  

这个 rm 命令会删除目录中的所有文件，还会抱怨没有文件叫做“.html”。  

小贴士。 无论什么时候， rm 命令用到通配符（除了仔细检查输入的内容外！），
用 ls 命令来测试通配符。这会让你看到要删除的文件列表。然后按下上箭头按键，
重新调用刚刚执行的命令，用 rm 替换 ls。  

## ln-创建链接
```
ln file link
```
创建硬链接
```
ln -s item link
```
创建符号链接，"item"可以是一个文件或是一个目录。

## 硬链接

硬链接和符号链接比起来，硬链接是最初 Unix 创建链接的方式，而符号链接更加现代。在
默认情况下，每个文件有一个硬链接，这个硬链接给文件起名字。当我们创建一个硬链接以后，
就为文件创建了一个额外的目录条目。硬链接有两个重要局限性：  

\1. 一个硬链接不能关联它所在文件系统之外的文件。这是说一个链接不能关联与链接本身
不在同一个磁盘分区上的文件。
\2. 一个硬链接不能关联一个目录。  

一个硬链接和文件本身没有什么区别。不像符号链接，当你列出一个包含硬链接的目录内
容时，你会看到没有特殊的链接指示说明。当一个硬链接被删除时，这个链接被删除，但是文
件本身的内容仍然存在（这是说，它所占的磁盘空间不会被重新分配），直到所有关联这个文
件的链接都删除掉。

## 符号链接

创建符号链接是为了克服硬链接的局限性。符号链接生效，是通过创建一个特殊类型的文
件，这个文件包含一个关联文件或目录的文本指针。在这一方面，它们和 Windows 的快捷方
式差不多，当然，符号链接早于 Windows 的快捷方式很多年;-)  

一个符号链接指向一个文件，而且这个符号链接本身与其它的符号链接几乎没有区别。例
如，如果你往一个符号链接里面写入东西，那么相关联的文件也被写入。然而，当你删除一个
符号链接时，只有这个链接被删除，而不是文件自身。如果先于符号链接删除文件，这个链接
仍然存在，但是不指向任何东西。在这种情况下，这个链接被称为坏链接。在许多实现中， ls
命令会以不同的颜色展示坏链接，比如说红色，来显示它们的存在。  

注意：
```
mv dir1 dir2
```
如果dir2已经存在，则把dir1移进dir2里面，若dir2不存在，把dir1改名为dir2。再把dir1原来内容放进去。

## 创建硬链接
一个文件至少有一个硬链接，因为文件名就是由链接创建的。
当考虑到硬。链接的时候，可以假设文件由两部分组成：包含文件内容的数据部分和持有文件名的名字部分。当我们创建文件硬链接的时候，实际上是为文件创建了额外的名字部分，并且这些名字都关系到相同的数据部分。这时系统会分配一连串的磁盘给所谓的索引节点，然后索引节点与文件名字部分相关联。。因此每一个硬链接都关系到一个具体的包含文件内容的索引节点。
ls命令有一种方法，来展示（文件索引节点）的信息。在命令中加上"-i"选项。
这个版本的列表中，第一字段表示文件索引节点号。
## 创建符号链接
建立符号链接的目的是为了客服硬链接的两个缺点：硬链接不能跨越物理设备，硬链接不能关联目录，只能是文件。符号链接是文件的特殊类型，它包含一个指向目标文件或目录的文本指针。

注意：
```
ln -s fun dir1/fun-sym
```
这样就会形成坏链接
应该是
```
ln -s ../fun dir1/fun-sym
```
我猜 之所以加点点是因为 fun是在dir1的父目录里面 我猜的

```
[me@linuxbox playground]$ ls -l dir1
total 4
-rw-r--r-- 4 me me 1650 2008-01-10 16:33 fun-hard
lrwxrwxrwx 1 me me
6 2008-01-15 15:17 fun-sym -> ../fun
```

目录 dir1 中，fun-sym 的列表说明了它是一个符号链接，通过在第一字段中的首字符 “l”
可知，并且它还指向 “../fun”，也是正确的。相对于 fun-sym 的存储位置，fun 在它的上一个目录。同时注意，符号链接文件的长度是 6，这是字符串 “../fun” 所包含的字符数，而不是符号链接所指向的文件长度。
建立符号链接，既可以使用绝对路径名，也可以使用相对路径名。相对路径名更令人满意，因为它允许一个包含符号链接的目录重命名或移动，而不会破坏链接。
除了普通文件，符号链接也能关联目录
## 移动发文件和目录
删除一个文件 则它的符号链接指向已经不存在的文件，链接已经坏了
大多数Linux发行版配置ls显示损坏的链接。在Fedora系统中，坏的链接以闪烁的红色文本显示!损坏链接的出现，并不危险，但是相当混乱。
对于符号链接，执行的大多数文件操作是针对链接的对象，而不是链接本身。而rm命令是个特例。当你删除链接的时候，删除链接本身，而不是链接的对象。
删除文件夹，需要在rm后加上-r
> 用GUI创建符号链接  
> 文件管理器GNOME和KDE都提供了一个简单而自动化的方法来创建符号链接。  
> 在GNOME里，当拖动文件时，同时按下Ctrl＋Shift按键会创建一个链接，而不是复制（或移动）文件。在KDE中，无论什么时候放下一个文件，会弹出一个小菜单，这个菜单会提供复制，移动，或创建链接文件选项。  


## 使用命令
### 什么是命令
命令可以是下面四中形式之一：
1. 是一个可执行程序，如同目录/usr/bin中的文件一样。属于这一类的程序，可以编译成二进制文件，诸如用C和C＋＋语言写的程序，也可以是由脚本语言写成的程序，比如说shell,perl,python,ruby，等等。
2. 是一个内建于shell自身的命令。bash支持若干命令，内部叫做shell内部命令（builtins）。例如，cd命令，就是一个shell内部命令。
3. 是一个shell函数。这些是小规模的shell脚本，它们混合到环境变量中。
4. 是一个命令别名。可以定义自己的命令，建立在其它命令之上。

## 识别命令
能确切地知道正在使用四类命令中的哪一类经常很有用。Linux提供了方法来弄明白命令类型。

## type-显示命令的类型
type是shell内部命令，它会显示命令的类别，给出一个特定的命令名（做为参数）。它像这样工作：
```
type command
```
一些例子：
```
$ type type
type is a shell builtins
$ type ls
ls is aliased to 'ls --color=tty'
$ type cp
cp is /bin/cp
```
注意：ls命令实际上是ls命令加上选项“--color=auto”的别名。这也是为什么ls的输出结果是有颜色的。

## which——显示一个可执行程序的位置
有时候在一个操作系统中，不只安装了可执行程序的一个版本。然后在桌面系统中，这并不普遍，但在大型服务器中，却很平常。为了确定所给定的执行程序的准确位置，使用which命令:
```
$ which ls
/bin/ls
```
这个命令只对可执行程序有效，不包括内部命令和命令别名，别名是真正的可执行程序的替代物。当试着使用shell内部命令时，或者得不到回应，或者是个错误信息。
## 得到命令文档
### help-得到shell内部命令的帮助文档
```
$ help cd
cd: cd [-L|-P] [dir]
Change...
```
注意表示法:出现在命令语法说明中的方括号，表示可选的项目。一个竖杠字符表示互斥选项。在上面cd命令的例子中，cd命令可能有一个“-L”选项或者“-P”选项，进一步，可能有参数“dir”。
## --help - 显示用法信息
许多可执行程序支持一个--help选项，这个选项是显示命令所支持的语法和选项说明。例如：
```
$ mkdir --help
Usage: mkdir  [OPTION] DIRECTORY...
Create ...
```

## man -显示程序手册页
许多希望被命令行使用的可执行程序，提供了一个正式的文档，叫做手册或手册页。一个特殊的叫做man的分页程序，可用来浏览它们。
```
man program
```
手册文档一般包含一个标题，命令语法的纲要，命令用途的说明，和命令选项列表，及每个选项的说明。但通常手册文档不包含实例。
```
$ man ls
```
在大多数Linux系统中，man使用less工具来显示参考手册，所以当浏览文档时，less命令都能有效。
man所显示的参考手册，被分成了几个章节，它们不仅仅包括用户命令，也包括系统管理员命令，程序接口，文件格式等。
|章节 |内容 |
|:-:|:-:|
|1 |用户命令 |
|2 |程序接口内核系统调用 |
|3 |C库函数程序接口 |
|4 |特殊文件，比如说设备结点和驱动程序 |
|5 |文件格式 |
|6 |游戏娱乐，如屏幕保护程序 |
|7 |其他方面 |
|8 |系统管理员命令 |


有时候，需要查看参考手册的特定章节，从而找到需要的信息。  
如果我们要查找一种文件格式，而同时它也是一个命令名时，这种情况尤其正确。  
没有指定章节号，我们总是得到第一个匹配项，可能在第一章节。
```
man section search_term
```
例如
```
$ man 5 passwd
```
命令运行结果会显示文件/etc/passwd的文件格式说明手册。
## apropos——显示适当的命令
也有可能搜索参考手册列表，基于某个关键字的匹配项。虽然很粗糙但有时很有用。
```
$ apropos floppy
```
输出结果每行的第一个字段是手册页的名字，第二个字段展示章节。注意，man命令加上“-k”选项，和apropos完成一样的功能。
## whatis——显示非常简洁的命令说明
whatis程序显示匹配特定关键字的手册页的名字和一行命令说明
## info——显示程序info条目
GNU项目提供了一个命令程序手册页的替代物，称为“info”，其内容可通过info阅读器程序读取。info页是超链接形式的，和网页很相似。
info程序读取info文件，info文件是树型结构，分化为各个结点，每一个包含一个题目。info文件包含超级链接，它可以让你从一个结点跳到另一个结点。一个超级链接可通过它开头的星号辨别出来，把光标放在上面按enter键，就可以激活。
输入“info”，接着输入程序名称，启动info。 下表中的命令，当显示一个info页面时，用来控制阅读器。
|命令 |行为 |
|:-:|:-:|
|？ |显示命令帮助 |
|PgUp or Backspace |显示上一页 |
|PgDn or Space |显示下一页 |
|n |下一个 显示下一个结点 |
|p |上一个 显示上一个结点 |
|u |Up 显示当前所显示结点的父结点，通常是个菜单 |
|Enter |激活光标位置下的超级链接 |
|q |退出 |

到目前为止，我们所讨论的大多数命令行程序，属于GNU项目的“coreutils”包，输入：
```
$ info coreutils
```
将会显示一个包含超级链接的手册页，这些超级链接指向包含在coreutils包中的各个程序。

## README和其它程序文档
很多安装在系统中的软件，都有自己的文档文件，这些文件位于/usr/share/doc目录下，这些文件大多数是以文本文件形式存储的，可以用less阅读器浏览。一些文件是HTML格式，可用网页浏览器阅读。以“.gz”结尾的文件表示gzip压缩程序已经压缩了这些程序。gzip软件包包括一个特殊的less版本，叫做zless，zless可以显示由gzip压缩的文本文件的内容。
## 用别名（alias）创建你自己的命令
小技巧：把多个命令放在同一行上，命令之间用“;”分开。
```
command1;command2;command3...
```
例如
```
$ cd /usr; ls; cd ~
```
首先更改目录到/usr，然后列出目录内容，最后回到原始目录（用命令“cd~”），结束在开始的地方。
现在，通过alias命令把这一串命令转变为一个命令。给新命令取个名字，比如“test”，在使用“test”之前，查明是否“test”命令名已经存在在系统中，是个很不错的主意。可以使用type命令：
```
$ type test
test is a shell builtin
```
可见，“test”名字已经被使用了。试一下“foo”
```
$ type foo
bash: type: foo: not found
```
“foo”没被占用。创建命令别名：
```
$ alias foo='cd /usr; ls; cd ~'
```
主意命令的结构：
```
alias name='string'
```
在命令“alias”之后，输入“name”，紧接着（没有空格）是一个等号，等号后是引号引起的字符串，字符串内容赋值给name。
删除别名，使用unalias命令，像这样：
```
$ unalias foo
$ type foo
bash: type: foo: not found
```
要查看所有定义在系统环境中的别名，使用不带参数的alias命令。
```
$ alias
```
在命令行中定义别名有小问题。当shell会话结束时，它们会消失。可以把别名添加到文件中去，每次登录系统，这些文件会建立系统环境。
## 重定向
I/O重定向，通过这个工具，可以重定向命令的输入输出，命令的输入来自文件，而输出也存到文件。也可以把多个命令连接起来组成一个强大的命令管道。  
* cat 连接文件
* sort 排序文本行
* uniq 报道或省略重复行
* grep 打印匹配行
* wc 打印文件中换行符，字，和字节个数
* head 输出文件第一部分
* tail 输出文件最后一部分

## 标准输入，输出和错误
许多程序都会产生某种输出。这种输出，经常由两种类型组成。第一，程序运行结果；即程序要完成的功能。第二，我们得到状态和错误信息，这些告诉我们程序进展。  
与Unix主题“任何东西都是一个文件”保持一致，程序，比方说ls，实际上把他们的运行结果输送到一个叫标准输出的特殊文件（经常用stdout表示），而状态信息则送到另一个叫做标准错误的文件（stderr）。默认情况下，标准输出和标准错误都连接到屏幕，而不是保存到磁盘文件。此外，许多程序从一个叫做标准输入（stdin）的设备得到输入，默认情况下，标准输入连接到键盘。
I/O重定向允许我们可以更改输出走向和输入来向。一般地，输出送到屏幕，输入来自键盘，但是通过I/O重定向，可以改变输入输出方向。
## 重定向标准输出
有时候把一个命令的运行结果存储到一个文件很有用处。
```
$ ls -l /usr/bin > ls-output.txt
```

假设把目录换成一个不存在的目录。
```
$ ls -l /bin/usr > ls-output.txt
ls: cannot access /bin/usr: No such file or directory
```
错误信息显示在屏幕上而不是被重定向到文件ls-output.txt。因为ls程序不把它的错误信息输送到标准输出，而是送到标准错误。
```
$ ls -l ls-output.txt
-rx-rx-r-- 1 me me 0 2008-02-01 15:08 ls-output.txt
```
文件长度为0，因为使用">"重定向符重定向输出结果时，目标文件总是从开头被重写。因为ls命令没有产生运行结果，只有错误信息，重定向操作开始重写文件，然后由于错误而停止，导致文件内容删除。

事实上，如果需要删除一个文件内容（或者创建一个新的空文件），可以使用这样的技巧：
```
$ > ls-output.txt
```
简单地使用重定向符，没有命令在它之前，这会删除一个已存在文件的内容或是创建一个新的空文件。

要想把重定向结果追加到文件内容后面，而不是从开头重写文件，使用“>>”重定向符
```
$ ls -l /usr/bin >> ls-output.txt
```
## 重定向标准错误
重定向标准错误缺乏专用的重定向操作符。

迷惑的一段话： 一个程序可以在几个编号的文件流中的任一个上产生输出。然而我们必须把这些文件流的前三个看做标准输入，输出和错误，shell内部参考它们为文件描述符0，1和2，各自地，shell提供了一种表示法来重定向文件，使用文件描述符。因为标准错误和文件描述符2一样
```
$ ls -l /bin/usr 2> ls-error.txt
```
## 重定向标准输出和错误到同一个文件
当希望捕捉一个命令的所有输出到一个文件。有两种方法来完成任务。
```
$ ls -l /bin/usr > ls-output.txt 2>&1
```
使用这种方法，完成两个重定向。首先重定向标准输出到文件ls-output.txt，然后重定向文件描述符2（标准错误）到文件描述符1（标准输出）使用表示法2>&1。

注意重定向的顺序安排非常重要。标准错误的重定向必须总是出现在标准输出重定向之后，要不然它不起作用。
```
>ls-output.txt 2>&1
```
重定向标准错误到文件ls-output.txt，但是如果命令顺序改为：
```
2>&1 >ls-output.txt
```
则标准错误定向到屏幕。

现在的bash版本提供了第二种方法，更精简合理地执行这种联合的重定向。
```
$ ls -l /bin/usr &> ls-output.txt
```
在这个例子里，使用&>来重定向标准输出和错误到文件ls-output.txt。
## 处理不需要的输出
有时我们不想要一个命令的输出结果，只想把它们扔掉。这种情况尤其适用于错误和状态信息。系统为我们提供了解决问题的方法，通过重定向输出结果到一个特殊的叫做"/dev/null"的文件。这个文件是系统设备，叫做位存储桶，它可以接受输入，并且对输入不做任何处理。为了隐瞒命令错误信息，这样做：
```
$ ls -l /bin/usr 2> /dev/null
```
位存储桶是个古老的Unix概念。

## 重定向标准输入
## cat——连接文件
cat命令读取一个或多个文件，然后复制它们到标准输出
```
cat [file]
```
大多情况下，可以认为cat命令相似于DOS中的TYPE命令。可以使用cat来显示文件而没有分页，例如
```
$ cat ls-output.txt
```
将会显示文件ls-output.txt的内容。cat经常被用来显示简短的文本文件。
因为cat可以接受不只一个文件作为参数，所以它也可以用来把文件连接在一起。比方说我们下载了一个大型文件，这个文件被分离成多个部分(USENET中的多媒体文件经常以这种方式分离），我们想把它们连起来。如果文件命名为：
movie.mpeg.001 movie.mpeg.002 ... movie.mpeg.009
用这个命令把它们连接起来：
```
cat movie.mpeg.0* > movie.mpeg
```
因为通配符总是以有序的方式展开，所以这些参数会以正确顺序安排。

如果输入不带参数的“cat”命令，会发生什么？
```
$ cat
```
如果cat没有给出任何参数，它会从标准输入读入数据，因为标准输入，默认情况下，连接到键盘。
下一步，输出Ctrl-d，来告诉cat，在标准输入中，它已经到达文件末尾（EOF）
由于文件名参数的缺席，cat复制标准输入到标准输出。  
试着重定向标准输入：
```
$ cat < lazy_dog.txt
```
使用“`<`” 重定向操作符，把标准输入源从键盘改到文件lazy_dog.txt。
## 管道线
使用管道操作符“|”,一个命令的标准输出可以管道到另一个命令的标准输入：
```
command1 | command2
```
less命令接受标准输入。可以用less来一页一页地显示任何命令的输出，命令把它的运行结果输送到标准输出：
```
$ ls -l /usr/bin | less
```
这样 可以方便地检测会产生标准输出的任一命令的运行结果。

## 过滤器
管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。通常，以这种方式使用的命令被称为过滤器。过滤器接受输入，以某种方式改变它，然后输出它。
例如，sort过滤器
```
$ ls /bin /usr/bin | sort | less
```
因为指定了两个目录（/bin和/usr/bin），ls命令的输出结果由有序列表组成，各自针对一个目录。通过在管道线中包含sort，我们改变输出数据，从而产生一个有序列表。
## uniq——报道或忽略重复行
uniq命令经常和sort命令结合在一起使用。uniq从标准输入或单个文件名参数接受数据有序列表，默认情况下，从数据列表中删除任何重复行。为了确信我们的列表中不包含重复句子，我们添加uniq到我们的管道线中：
```
$ ls /bin /usr/bin | sort | uniq | less
```
上例为使用uniq从sort命令的输出结果中，来删除任何重复行。如果我们想看到重复的数据列表，让uniq命令带上“-d”选项，就像这样：
```
$ ls /bin /usr/bin | sort | uniq -d | less
```
## wc——打印行，字和字节数
wc(字计数）命令是用来显示文件所包含的行，字和字节数。如：
```
$ wc ls-output.txt
7902 64566 503634 ls-output.txt
```
wc打印出来的三个数字，依次为行数、单词数、字节数。
如果wc不带参数，它接受标准输入。“-l”选项限制命令输出只能报道行数。
查看我们的有序列表中程序个数，可以这样做：
```
$ ls /bin /usr/bin | sort | uniq | wc -l
2728
```
## grep —— 打印匹配行
grep用来找到文件中的匹配文本。
```
grep pattern [file...]
```
当grep遇到一个文件中的匹配“模式”，它会打印处包含这个类型的行。  
例如，想在程序列表中，找到文件名中包含单词“zip”的所有文件。这样一个搜索，可能让我们了解系统中的一些程序与文件压缩有关系。
```
$ ls /bin /usr/bin | sort | uniq | grep zip
bunzip2
bzip2
gunzip
...
```
grep有一对方便的选项：“-i”导致grep忽略大小写当执行搜索时（通常，搜索是大小写敏感的），“-v”选项会告诉grep只打印不匹配的行。
## head/tail——打印文件开头部分/结尾部分
head命令打印文件的前十行，tail命令打印文件的后十行。  
默认情况下，两个命令都打印十行文本，但可以通过“-n”选项来调整命令打印的行数。
```
$ head -n 5 ls-output.txt
total 343496
...
$ tail -n 5 ls-output.txt
...
```
它们也能用在管道线中：
```
$ ls /usr/bin | tail -n 5
znew
...
```
tail有一个选项允许你实时浏览文件。当观察日志文件的进展时，这很有用，因为它们同时在被写入。

在下面的例子里，我们要查看目录/var/log里面的信息文件。在一些Linux发型版中，要求有超级用户权限才能阅读这些文件，因为文件/var/log/messages可能包含安全信息。
```
$ tail -f /var/log/message
Feb 8 13:40:05 twin4 dhclient: DHCPACK from 192.168.1.1
...
```
使用“-f”选项，tail命令继续监测这个文件，当新的内容添加到文件后，它们会立即出现在屏幕上。这会一直继续下去直到你输入Ctrl-c。
## tee ——从Stdin读取数据，并同时输出到Stdout和文件
tee程序从标准输入读入数据，复制数据到标准输出（允许数据继续随着管道线流动）和一个或多个文件。当在某个中间处理阶段来捕捉一个管道线的内容时，很有帮助。下例显示在grep过滤管道线的内容之前，来捕捉整个目录列表到文件ls.txt:
```
$ ls /usr/bin | tee ls.txt | grep zip
bunzip2
bzip2
....
```
## 从shell眼中看世界
## （字符）展开
每次你输入一个命令，然后按下enter键，在bash执行你的命令之前，bash会对输入字符完成几个步骤的处理。使这个发生的过程叫做（字符）展开。通过展开，你输入的字符，在shell对它起作用之前，会展开成为别的字符。
echo是一个shell内部命令，它在标准输出中打印出它的文本参数。
```
$ echo this is a test
this is a test
```
传递到echo命令的任一个参数都会在屏幕上显示出来。

```
$ echo *
Desktop Documents ls-output.txt Music Pictures Public Templates Videos
```
为什么echo不打印“*”呢。“*”字符意味着匹配文件名中的任意字符，shell把“*”展开成了另外的东西，在这种情况下，就是在当前工作目录下的文件名字。  
当回车键被按下时，shell在命令被执行前在命令行上自动展开任何符合条件的字符，所以echo命令从不会发现“*”，只把它展开成结果。
## 路径名展开
这种通配符工作机制叫路径名展开。
隐藏文件路径名展开：以圆点字符开头的文件名是隐藏文件。路径名展开也尊重这种行为。像这样的展开：
`echo *`不会显示隐藏文件。
`echo .*`能够在展开模式中包含隐藏文件，而且隐藏文件可能会出现在第一位置。但会看到名字“.”和“..”也出现在结果中。因为这些名字是指当前工作目录和它的父目录，使用这种模式可能会产生不正确的结果。
为了在这种情况下正确地完成路径名展开，应该用一个更精确些的模式：`ls -d .[!.]?*`,这种模式展开称为文件名，每个文件名以圆点开头，第二个字符不包含圆点，再包含至少一个字符，并且这个字符之后紧接着任意多个字符。这将列出大多数的隐藏文件（但仍将不能包含以多个圆点开头的文件名）。  
这个带有-A选项（“几乎所有”）的ls命令能够提供一份正确的隐藏文件清单。
```
ls -A
```
## 波浪线展开
“~”有特殊意思。它用在一个单词的开头时，会展开成指定用户的家目录名，如果没有指定用户名，则是当前用户的家目录：
```
$ echo ~
/home/me
```
如果有用户“foo”这个账号，
```
$ echo ~foo
/home/foo
```
## 算术表达式展开

shell允许算术表达式通过展开执行。这允许我们把shell提示当做计算器来使用：
```
$ echo $((2+2))
4
```
算术表达式展开使用这种格式：
```
$((expression))
```
（以上括号中的）表达式是指算术表达式，它由数值和算术操作符组成。
算术表达式只支持整数，但是能执行很多不同的操作：
|操作符 |说明 |
|:-:|:-:|
|+ |加 |
|- |减 |
|* |乘 |
|/ |除（只支持整数除法，结果是整数） |
|% |取余 |
|** |取幂 |

在算术表达式中空格不重要，且表达式可以嵌套。例如，5的平方乘以3：
```
$ echo $(($((5**2)) * 3))
75
```
一对括号可以用来把多个字表达式括起来。可以重写上面的例子，同时用一个展开代替两个：
```
$ echo $(((5**2) * 3))
75
```
这是一个使用除法和取余操作符的例子。注意整数除法的结果：
```
$ echo Five divided by two equals $((5/2))
Five divided by two equals 2
$ echo with $((5%2)) left over.
with 1 left over.
```
## 花括号展开
可以从一个包含花括号的模式中创建多个文本字符串。
```
$ echo Front-{A,B,C}-Back
Front-A-Back Front-B-Back Front-C-Back
```
花括号展开模式可能包含一个开头部分叫做报头，一个结尾部分叫做附言。花括号表达式本身可能包含一个由逗号分开的字符串列表，或者一系列整数，或者单个的字符串。这种模式不能嵌入空白字符。
```
$ echo Number_{1..5}
Number_1 Number_2 Number_3 Number_4 Number_5
```


```
$ echo {Z..A}
Z Y X W V U T S R Q P O N M L K J I H G F E D C B A
```
花括号展开可以嵌套：
```
$ echo a{A{1,2},B{3,4}}b
aA1b aA2b aB3b aB4b
```
花括号展开的普遍应用是，创建一系列的文件或目录列表。比如把照片按年月先后组织起来。
```
$ mkdir Pics
$ cd Pics
$ mkdir {2007..2009}-0{1..9} {2007..2009}-{10..12}
$ ls
2007-01 2007-07 2008-01 2008-07 2009-01 2009-07
2007-02 2007-08 2008-02 2008-08 2009-02 2009-08
2007-03 2007-09 2008-03 2008-09 2009-03 2009-09
2007-04 2007-10 2008-04 2008-10 2009-04 2009-10
2007-05 2007-11 2008-05 2008-11 2009-05 2009-11
2007-06 2007-12 2008-06 2008-12 2009-06 2009-12
```
## 参数展开
这个特性在shell脚本中比直接在命令行中更有用。它的许多性能和系统存储小块数据，并给每块数据命名的能力有关系。许多像这样的小块数据，更适当些应叫做变量，可以方便地检查它们。例如，叫做“USER”的变量包含你的用户名。唤醒参数展开，解释USER中的内容，可以了这样做：
```
$ echo $USER
me
```
查看有效的变量列表，试试这个：
```
$ printenv | less
```
其他展开类型中如果你误输入一个模式，展开就不会发生。这时echo命令只简单地显示误键入的模式。而通过参数展开，如果你拼错了一个变量名，展开仍然会进行，只是展成一个空字符串：
```
$ echo $SUER

$
```
## 命令替换
命令替换允许我们把一个命令的输出作为一个展开模式来使用：
```
$ echo $(ls)
Desktop Documents ls-output.txt Music Pictures Public Templates
Videos
```
看这个例子：
```
$ ls -l $(which cp)
-rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp
```
这里把which cp的执行结果作为一个参数传递给ls命令，因此要想得到cp程序的输出列表，不必知道它完整的路径名。我们不只限制于简单命令。也可以使用整个管道线（只展示部分输出）：
```
$ file $(ls /usr/bin/* | grep zip)
/usr/bin/bunzip2:    symbolic link to 'bzip2'
....
```
这个例子中，管道线的输出结果称为file命令的参数列表
在旧版shell程序中，有另一种语法也支持命令替换，bash也支持这种语法。它使用到引号来代替美元符号和括号：
```
$ ls -l `which cp`
-rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp
```
## 引用
```
$ echo this is a    test
this is a test
```

```
$ echo The total is $100.00
The total is 00.00
```
第一个例子中，shell从echo命令的参数列表中，删除多余的空格。第二个例子中，参数展开把`$1`的值替换为一个空字符串，因为1是没有定义的变量。shell提供了一种叫做引用的机制，来有选择地禁止不需要的展开。
## 双引号
引用的第一种类型,放在双引号中文本，除了`$`,`\`（反斜杠）,和`(倒引号）之外，shell使用的特殊字符，将失去其特殊含义，被当做普通字符看待。这意味着单词分割、路径名展开，波浪线展开，花括号展开都被禁止，然而参数展开，算术展开，和命令替换仍然执行。  
使用双引号，可以处理包含空格的文件名。比如two words.txt。当试图在命令行中使用这个文件，单词分割机制会导致这个文件名被看做两个独自的参数。
```
$ ls -l two words.txt
ls: cannot access two: No such file or directory
ls: cannot access words.txt: No such file or directory
```
使用双引号，我们可以阻止单词分割，得到期望的结果，进一步，甚至可以修复破损的文件名。
```
$ ls -l "two words.txt"
-rw-rw-r-- 1 me me 18 2008-02-20 13:03 two words.txt
$ mv "two words.txt" two_words.txt
```
在双引号中，参数展开，算术表达式展开，和命令替换仍然有效：
```
$ echo "$USER $((2+2)) $(cal)"
me 4 February 2008
Su Mo Tu We Th Fr Sa
...
```
单词分割是怎样工作的？
在默认情况下，单词分割机制会在单词中寻找空格、制表符、换行符，并把它们看做单词之间的界定符。双引号中单词分割被禁止，内嵌的空格也不会被当做界定符。
单词分割机制把换行符看做界定符，对命令替换产生了一个微妙的影响，如下例：
```
$ echo $(cal)
February 2008 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14
15 16 17 18 19 20 21 22 23 24 25 26 27 28 29
$ echo "$(cal)"
February 2008
...
```
在第一个实例中，没有引用的命令替换导致命令行包含38个参数。在第二个例子中，命令行只有一个参数，参数中包括嵌入的空格和换行符。
## 单引号
如果需要禁止所有的展开，使用单引号。
```
$ echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER
text /home/me/ls-output.txt a b foo 4 me
$ echo "text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER"
text ~/*.txt {a,b} foo 4 me 
$ echo 'text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER'
text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER
```
## 转义字符
有时候只想引用单个字符。可以在字符之前加上一个反斜杠，在这个上下文中叫转义字符。经常在双引号中使用转义字符，来有选择地阻止展开。
```
$ echo "The balance for user $USER is : \$5.00"
The balance for user me is $5.00
```
使用转义字符来消除文件名中一个字符的特殊含义。比如，在文件名中可能使用一些对于shell来说有特殊含义的字符。这些字符包括“$”,"!","&"等字符。在文件名中包含特殊字符，可以这样做：
```
$ mv bad\&filename good_filename
```
注意在单引号中，反斜杠失去它的特殊含义，被看做普通字符。

反斜杠转义字符序列(Backslash Escape Sequences)
反斜杠除了作为转义字符外，也是一种表示法的一部分，这种表示法代表某种特殊字符，叫做控制码。ASCII编码表中前32个字符被用来把命令传输到像电报机一样的设备。一些编码是众所周知的（制表符，退格符，换行符，和回车符），其他一些编码就不熟悉了（控制，传输结束吗，和确认）。
|转义序列 |含义 |
|:-:|:-:|
|\a |响铃（“警告”——导致计算机嘟嘟响） |
|\b |退格符 |
|\n |新的一行。在类Unix系统中，产生换行。 |
|\r |回车符 |
|\t |制表符 |

反斜杠表示法背后的思想来源于C编程语言，许多其他语言也采用了这种表示方法，包括shell。

echo命令带上'-e'选项，能够解释转义序列。可以把转义序列放在$''里面。以下例子，使用sleep命令，一个简单的程序，它会等待指定的秒数，然后退出。我们可以创建一个简单的倒数计数器：
```
sleep 10; echo -e "Time's up\a"
```
也可以这样做
```
sleep 10;echo "Time's up" $'\a'
```
如果没有准确地理解展开模式，shell总是神秘和混乱的源泉，并且shell潜在的能力也浪费掉了。
## 键盘高级操作技巧
命令行最为诊视的目标之一就是懒惰，用最少的击键次数来完成最多的工作。另一个目标是你的手指永远不必离开键盘，永不触摸鼠标。
bash特性使键盘使用起来更加迅速，更加高效。
## 命令行编辑
Bash使用了一个名为Readline的库（共享的线程集合，可以被不同的程序使用），来实现命令行编辑。
注意下面一些按键组合（尤其使用Alt键的组合），可能会被GUI拦截来触发其它的功能。当使用虚拟控制台时，所有的按键组合都应该正确地工作。
## 移动光标
|按键 |行动 |
|:-:|:-:|
|Ctrl-a |移动光标到行首 |
|Ctrl-e |移动光标到行尾 |
|Ctrl-f |光标前移一个字符；和右箭头作用一样 |
|Ctrl-b |光标后移一个字符；和左箭头作用一样 |
|Alt-f |光标前移一个字 |
|Alt-b |光标后移一个字 |
|Ctrl-l |清空屏幕，移动光标到左上角。clear命令完成同样的工作 |
## 修改文本
|按键 |行动 |
|:-:|:-:|
|Ctrl-d |删除光标位置的字符 |
|Ctrl-t |光标位置的字符和光标前面的字符互换位置 |
|Alt-t |光标位置的字和其前面的字互换位置 |
|Alt-l |把从光标位置到字尾的字符换成小写字母 |
|Alt-u |把从光标位置到字尾的字符转换成大写字母 |


## 剪切和粘贴文本
Readline的文档使用术语killing和yanking来指我们平常所说的剪切和粘贴。剪切下来的文本被存储在一个叫做剪切环（kill-ring）的缓冲区中。

|按键 |行动 |
|:-:|:-:|
|Ctrl-k |剪切从光标位置到行尾的文本 |
|Ctrl-u |剪切从光标位置到行首的文本 |
|Alt-d |剪切从光标位置到词尾的文本 |
|Alt-Backspace |剪切从光标位置到词头的文本。如果光标在一个单词的开头，剪切前一个单词。 |
|Ctrl-y |把剪切环中的文本粘贴到光标位置 |

元键（Meta Key）
元键，在当今的键盘上，指Alt键，但并不总是这样。
PC之前Unix之后的年代，并不是每个人都有他们自己的计算机。他们可能有一个叫做终端的设备。一个终端是一种通信设备，它以一个文本显示屏幕和一个键盘作为其特色。它连接到（通常通过串行电缆）一个更大的计算机或者是一个大型计算机的通信网络。
Unix系统有一个非常精巧的方法来处理各种终端产品和它们不同的显示特征。因为Readline程序的开发者们，不能确定一个专用多余的控制键的存在，他们发明了一个控制键，并把它叫做“元”（“meta”）。在Linux中，仍然有终端，可以按下或释放Esc键来得到如控制Alt键一样的效果。
## 自动补全
自动补全也能对变量起作用（如果字的开头是一个“$”），用户名字（单词以“~”开始），命令（如果单词是一行的第一个单词）和主机名（如果单词开头是“@”）。主机名自动补全只对包含在文件/etc/hosts中的主机名有效。
有一系列的控制和元键序列与自动补全相关联：
|按键 |行动 |
|:-:|:-:|
|Alt-? |显示可能的自动补全列表。在大多数系统中，也可以通过按两次tab来实现，这回更容易 |
|Alt-* |插入所有可能的自动补全。适用于你想要使用多个可能的匹配项 |

## 可编程自动补全
## 利用历史命令
bash维护着一个已经执行过的命令的历史列表。这个命令列表保存在你家目录下，一个叫做.bash_history的文件里。
## 搜索历史命令
浏览历史列表的内容
```
$ history | less
```
默认情况下，bash会存储你所输入的最后500个命令。
如果我们想要找到列出目录/usr/bin内容的命令。可以这样做:
```
$ history  | grep /usr/bin
```
比如在我们的搜索结果之中，得到一行：
```
88 ls -l /usr/bin > ls-output.txt
```
数字“88”是这个命令在历史列表中的行号。随后在使用另一种展开类型时，叫做历史命令展开，可以这样做：
```
$ ! 88
```
## 递增搜索
```
$
```
首先输入Ctrl-r
```
(reverse-i-search)`':
```
提示符改变，显示正在执行反向递增搜索。搜索是“反向的”，因为我们按照从“现在”到过去某个时间段的顺序来搜寻。下一步，输入要查找的文本。在这个例子里是“/usr/bin”:
```
(reverse-i-search)`/usr/bin':ls -l /usr/bin > ls-output.txt
```
即刻，搜索返回我们需要的结果。可以执行这个命令，按下Enter键，或者可以复制这个命令到我们当前的命令行，来进一步编辑它，输入Ctrl-j。复制它，输入Ctrl-j:
```
$ ls -l /usr/bin > ls-output.txt
```
shell提示符重新出现，命令行加载完毕。

一些用来操作历史列表的按键组合：
|按键 |行为 |
|:-:|:-:|
|Ctrl-p |移动到上一个历史条目。类似于上箭头按键。 |
|Ctrl-n |移动到下一个历史条目。类似于下箭头按键。 |
|Alt-< |移动到历史列表开头。 |
|Alt-> |移动到历史列表结尾，即当前命令行。 |
|Ctrl-r |反向递增搜索。从当前命令行开始，向上递增搜索 |
|Alt-p |反向搜索，不是递增顺序。输入要查找的字符串，然后按下Enter，执行搜索。 |
|Alt-n |向前搜索，非递增顺序。 |
|Ctrl-o |执行历史列表中的当前项，并移到下一个。 |

## 历史命令展开
通过使用个“!”字符，shell为历史列表中的命令，提供了一个特殊的展开类型。
|序列 |行为 |
|:-:|:-:|
|！！ |重复最后一次执行的命令。可能按下上箭头按键和enter键更容易写。|
|！number |重复历史列表中第number行的命令。 |
|！string |重复最近历史列表中，以这个字符串开头的命令。 |
|！？string |重复最近历史列表中，包含这个字符串的命令。 |

应该小心谨慎使用“！string”和“！？string”格式，除非你完全确信历史列表条目的内容。bash手册页HISTORY EXPANSION部分详尽地讲述了所有要素。

脚本
许多Linux发行版包括一个叫做script的程序，这个程序可以记录整个shell会话，并把shell会话存在一个文件里面。这个命令的基本语法是：
```
script [file]
```
命令中的file是指用来存储shell会话记录的文件名。如果没有指定文件名，则使用文件typescript。查看脚本的手册页，可以得到一个关于script程序选项和特点的完整列表。
## 权限
Unix传统中的操作系统不同于那些MS-DOS传统中的系统，区别在于它们不仅是多任务系统，而且也是多用户系统。
ssh：安全shell
## 拥有者，组成员，和其他人
在Unix安全模型中，一个用户拥有一个文件或目录时，用户对这个文件或目录的访问权限拥有控制权。用户属于用户组，用户组成员由文件和目录的所有者授予对文件和目录的访问权限。文件所有者可能会给每个人一些权限，在Unix术语中，每个人是指整个世界。可以用id命令，来找到关于你自己身份的信息：
```
$ id
uid=500(me) gid=500(me) groups=500(me)
```
当用户创建账户之后，系统会给用户分配一个号码，叫做用户ID或者uid，然后为了符合人类的习惯，这个ID映射到一个用户名。系统又会给这个用户分配一个原始的组ID或者是gid，这个gid可能属于另外的组。

Fedora系统从500开始进行普通用户账户的编号，而Ubuntu从1000开始。Ubuntu的用户属于更多的用户组。这个Ubuntu管理系统设备和服务权限的方式有关系。

用户账户定义在/etc/passwd文件里面。用户组定义在/etc/group文件里面。当用户账户和用户组创建以后，这些文件随着文件/etc/shadow的变动而修改，文件/etc/shadow包含了关于用户密码的信息。对于每个用户账号，文件/etc/passwd定义了用户（登录）名，uid，gid，账号的真实姓名，家目录，和登录shell。

如果你查看以下文件/etc/passwd和文件/etc/group的内容，你会注意到除了普通用户账号之外，还有超级用户（uid0）账号，和各种各样的系统用户。
许多Unix的系统会把普通用户分配到一个公共的用户组中，例如“users”，现在的Linux会创建一个独一无二的，只有一个成员的用户组，这个用户组与用户同名。这样使某种类型的权限分配更容易些。
## 读取，写入，和执行
对于文件和目录的访问权力是根据读访问，写访问，和执行访问来定义的。
```
$ > foo.txt
$ ls -l foo.txt
-rw-rw-r-- 1 me me 0 2008-03-06 14:52 foo.txt
```
列表的前十个字符是文件的属性。这十个字符的第一个字符表明文件类型。下表是你可能经常看到的文件类型
|属性 |文件类型 |
|:-:|:-:|
|- |一个普通文件 |
|d |一个目录 |
|l |一个符号链接。注意对于符号链接文件，剩余的文件属性总是“rwxrwxrwx”，而且都是虚拟值。真正的文件属性是指符号链接所指向的文件的属性 |
|c |一个字符设备文件。这种文件类型是指按照字节流，来处理数据的设备。比如说终端机，后者调制解调器 |
|b |一个块设备文件。这种文件类型是指按照数据块，来处理数据的设备，例如一个硬盘，后者CD-ROM盘。 |

剩下九个字符，叫做文件模式，代表文件所有者，文件组所有者，和其他人的读，写，执行权限。
## chmod——更改文件模式
只有文件的所有者或者超级用户才能更改文件或目录的模式。chomod命令支持两种不同的方法来改变文件模式：八进制数字表示法，或符号表示法。

现在，十六进制表示法（经常叫做“hex”）比八进制更普遍，但是很快会看到，用八进制来表示3个二进制数非常有用处...

通过八进制表示法，我们使用八进制数字来设置所期望的权限模式。因为每个八进制数字代表了3个二进制数字，这种对应关系，正好映射到用来存储文件模式所使用的方案上。
|Octal |Binary |File Mode |
|:-:|:-:|:-:|
|0 |000 |--- |
|1 |001 |--x |
|2 |010 |-w- |
|3 |011 |-wx |
|4 |100 |r-- |
|5 |101 |r-x |
|6 |110 |rw- |
|7 |111 |rwx |

通过使用3个八进制数字，我们能够设置文件所有者，用户组，和其他人的权限：
```
$ > foo.txt
$ ls -l foo.txt
-rw-rw-r-- 1 me me 0 2008-03-06 14:52 foo.txt
$ chomod 600 foo.txt
$ ls -l foo.txt
-rw------ 1 me me 0 2008-03-06 14:52 foo.txt
```
通过传递参数“600”，能够设置文件所有者的权限为读写权限，而删除用户组和其他人的所有权限。虽然八进制到二进制的映射看起来不方便，但通常只会用到一些常见的映射关系：7(rwx),6(rw-),5(r-x),4(r--),0(---)

chomod命令支持一种符号表示法，来指定文件模式。符号表示法分为三部分：更改会影响谁，要执行那个操作，要设置哪种权限。通过字符“u”，“g”，“o”和“a”的组合来指定要影响的对象，如下所示：
|u |“user”的简写，意思是文件或目录的所有者 |
|:-:|:-:|
|g |用户组 |
|o |“others”的简写，意思是其他所有的人 |
|a |“all”的简写，是“u”，“g”和“o”三者的联合 |

若没有指定字符，则假定使用“all”。执行的操作可能是一个“+”字符，表示加上一个权限，一个“-”，表示删除一个权限，或者是一个“=”，表示只有指定的权限可用，其它所有的权限被删除。
权限由“r”，“w”，“x”来指定。
|u+x |为文件所有者添加可执行权限 |
|:-:|:-:|
|u-x |删除文件所有者的可执行权限 |
|+x |为文件所有者，用户组，和其他所有人添加可执行权限。等价于a+x |
|o-rw |除了文件所有者和用户组，删除其他人的读权限和写权限 |
|go=rw |给用户组和其他人读写权限，若上述两类用户之前有执行权限，移除执行权限 |
|u+x,go=rw |给文件拥有者执行权限并给组和其他人读和执行权限。多种设定可以用逗号分开 |

符号表示法的优点是，允许你设置文件模式的单个组成部分的属性，而没有影响其他部分。

注意chomod命令的"--recursive"选项：它可以同时作用于文件和目录，所以它并不是那么有用，因为我们很少希望文件和目录拥有同样权限。

## 借助GUI来设置文件模式
略
## umask——设置默认权限
当创建一个文件时，umask命令控制着文件的默认权限。umask命令使用八进制表示法来表达从文件模式属性中删除一个位掩码。
```
$ rm -f foo.txt
$ umask
0002
$ > foo.txt
$ ls -l foo.txt
-rw-rw-r-- 1 me me 0 2008-03-06 14:53 foo.txt
```
先删除foo.txt，下一步，运行不带参数的umask命令，看下当前掩码值。响应数值是0002（0022是另一个常用值），这个数值是掩码的八进制表示形式。下一步，创建文件foo.txt，并且保留它的权限。

可以看到文件所有者和用户组都得到读权限和写权限，而其他人只是得到读权限。其他人没有得到写权限的原因是由掩码值决定的。重复实验，这次自己设置掩码值：
```
$ rm foo.txt
$ umask 0000
$ > foo.txt
$ ls -l foo.txt
-rw-rw-rw- 1 me me 0 2008-03-06 14:58 foo.txt
```
当掩码设置为0000（实质是关掉它）之后，我们看到其他人能够读写文件。看一下掩码的八进制形式。把掩码展开成二进制形式，然后与文件属性相比较，看看区别：
|Original file mode |--rw-rw-rw- |
|:-:|:-:|
|mask |000000000010 |
|Result |--rw-rw-r-- |

先忽略掉开头的三个零，注意掩码中若出现一个数字1，则删除文件模式中和这个1在相同位置的属性，在这是指其他人的写权限。这就是掩码要完成的任务。掩码的二进制形式中，出现数字1的位置，相应地关掉一个文件模式属性。看一下掩码0022的作用：
|Original file mode |--rw-rw-rw- |
|:-:|:-:|
|Mask |000000010010 |
|Result |--rw-r--r-- |

二进制中数字1出现的位置，相对应的属性被删除。
可以对掩码值进行各种试验，最后记得清理现场：
```
$ rm foo.txt; umask 0002
```
大多数情况，不必修改掩码值，但在一些高安全级别下，要能控制掩码值。

通常看到一个八进制权限掩码用三位数字表示，但从技术层面讲，四位数字更确切。因为除了读取，写入，执行 这个三个权限外，还有其它的，较少用到的权限设置。
比如setuid位（八进制4000）。它的作用：当应用到一个可执行文件时，它把有效用户ID从真正的用户（实际运行程序的用户）设置成程序所有者的ID。这种操作通常会应用到一些由超级用户所拥有的程序。当一个普通用户运行一个程序，这个程序由根用户（root）所有，并且设置了setuid位，这个程序运行时具有超级用户的特权，这样程序就可以访问普通用户禁止访问的文件和目录。这回引起安全方面的问题，所有可以设置setuid位的程序个数，必须控制在绝对小的范围内。  
再比如，setgid位（八进制2000），把有效用户组ID从真正的用户组ID更改为文件所有者的组ID。如果设置了一个目录的setgid位，则目录中新创建的文件具有这个目录用户组的所有权，而不是文件创建者所属用户组的所有权。
对于共享目录来说，当一个普通用户组中的成员，需要访问共享目录中的所有文件，而不管文件所有者的主用户组时，设置setgid位很有用处。  
再有，sticky位（八进制1000）这个继承于Unix，在Unix中，可能把一个可执行文件标志为“不可交换的”。在Linux中，会忽略文件的sticky位，但如果一个目录设置了sticky位，那它能阻止用户删除或重命名文件，除非用户是这个目录的所有者，或者是文件所有者，或是超级用户。这个经常用来控制访问共享目录，比方说/tmp。

看例子，使用chmod命令和符号表示法，来设置这些特殊的权限。首先，授予一个程序setuid权限。
```
chomod u+s program
```
下一步，授予一个目录setgid权限：
```
chmod g+s dir
```
最后，授予一个目录sticky权限：
```
chomod +t dir
```
浏览ls命令输出结果时，可以看到：  
一个程序被设置为setuid属性：
```
-rwsr-xr-x
```
具有setgid属性的目录
```
drwxrwsr-x
```
设置了sticky位的目录：
```
drwxrwxrwt
```

## 更改身份
有三种方式，可以拥有多重身份：
1. 注销系统并以其他用户身份重新登录系统。
2. 使用su命令
3. 使用sudo命令

在我们自己的shell中，su命令允许你，假定为另一个用户的身份，以这个用户的ID启动一个新的shell会话，或者是以这个用户的身份来发布一个命令。  
sudo命令允许一个管理员设置一个叫做/etc/sudoers的配置文件，并且定义了一些具体命令，在假定的身份下，特殊用户可以执行这些命令。  
算则su还是sudo很大程度上由你的Linux发行版来决定，你的发行版可能两个命令都包含，但系统配置可能会偏袒其中之一。

## su——以其他用户身份和组ID运行一个shell
su命令用来以另一个身份启动shell。
```
su [-[l]] [user]
```
如果包含“-l”选项，那么会为指定用户启动一个需要登录的shell。这意味着会加载此用户的shell环境，并且工作目录会更改到这个用户的家目录。如果不指定用户，那么就假定是超级用户。选项“-l”可以缩写为“-”。  
启动超级用户的shell：
```
$ su -
Password:
#
```
按下回车符后，shell提示输入超级用户的密码。如果密码输入正确，出现一个新的shell提示符，这表明这个shell具有超级用户特权（提示符的末尾字符是“#”而不是“$”），并且当前工作目录是超级用户的家目录（通常是/root）。一旦进入新的shell，就能执行超级用户所使用的命令。工作完成后，输入“exit”，则返回原来的shell：
```
# exit
$
```
以这种方式使用su命令，也可以只执行单个命令，而不是启动一个新的可交互的shell：
```
su -c 'command'
```
使用这种模式，命令传递到一个新的shell中执行。把命令用单引号引起来很重要，因为我们不想命令在我们的shell中展开，但需要在新的shell中展开。
```
$ su -c 'ls -l /root/*'
Password:
-rw------- 1 root root 754 2007-08-11 03:19 /root/anaconda-ks.cfg

/root/Mail:
total 0
$
```

## sudo——以另一个用户身份执行命令
管理员能够配置sudo命令，从而允许一个普通用户以不同身份（通常是超级用户），通过一种非常可控的方式来执行命令。

sudo命令不要求超级用户的密码。而是使用他自己的密码来认证。  
例如，sudo命令经过配置，允许我们运行一个虚构的备份程序，叫做“backup_script”，这个程序要求超级用户权限。通过sudo命令，这个程序会像这样运行：
```
$ sudo backup_script
Password:
System Backup Starting..
```
su和sudo的重要区别是sudo不会重新启动一个shell，也不会加载另一个用户的shell运行环境。这意味着命令不必用单引号引起来。想知道sudo命令可以授予哪些权限，使用“-l”选项，列出所有权限：
```
$ sudo -l
User me may run the following commands on this host:
(ALL) ALL
```
普通用户怎样完成某些需要超级用户权限的任务。包括安装和更新软件，编辑系统配置文件，和访问设备。Windows世界里通过授权用户管理员权限来完成。但这也会导致用户执行的程序拥有同样的能力，比如malware（恶意软件），比如电脑病毒，将自由地支配计算机。
Unix采取的方法是只有在需要的时候，才授予普通用户超级用户权限。这样普遍会用到su和sudo命令。
几年前，大多数Linux发行版都依赖于su命令，来达到目的。su命令不需要sudo命令所要求的配置，su命令拥有一个root账号，是Unix中的传统。但这回引起问题，所有用户会企图以root用户账号来操纵系统。这会消除所有那些讨厌的“权限被拒绝”的消息。这样会削弱Linux系统安全性能。  
引进Ubuntu时，创作者们采取了不同的策略。默认情况下，Ubuntu不允许用户登录到root账号（因为不能为root账号设置密码），而是使用sudo命令授予普通用户超级用户权限。
## chown——更改文件所有者和用户组
```
chown [owner][:[group]]file...
```
chown命令可以更改文件所有者和或文件用户组，依据于这个命令的第一个参数。
|参数 |结果 |
|:-:|:-:|
|bob |把文件所有者从当前属主更改为用户bob |
|bob:users |把文件所有者改为用户bob，文件用户组改为用户组user。 |
|:admins |把文件用户组改为组admins，文件所有者不变。 |
|bob: |文件所有者改为用户bob，文件用户组改为，用户bob登录系统时，所属的用户组。 |

例如，有两个用户，janet，拥有超级用户访问权限，而tony没有。用户janet想要从她的家目录复制一个文件到用户tony的家目录。因为用户janet想要tony能够编辑这个文件，janet把这个文件的所有者更改为tony:
```
$ sudo cp myfile.txt ~tony
Password:
$ sudo ls -l ~tony/myfile.txt
-rw-r--r-- 1 root 8031 2008-03-20 14:30 /home/tony/myfile.txt
$ sudo chown tony: ~tony/myfile.txt
$ sudo ls -l ~tony/myfile.txt
-rw-r--r-- 1 tony 8031 2008-03-20 14:30 /home/tony/myfile.txt
```
用户janet把文件从她的目录复制到tony的家目录。下一步，janet把文件所有者从root（使用sudo命令的原因）改到tony。通过在第一个参数中使用末尾的“：”字符，janet同时把文件用户组改为tony登录系统时所属的用户组，碰巧是用户组tony。
第一次使用sudo后，sudo命令会相信你几分钟，直到计时结束。此时不用再输入密码。
## chgrp——更改用户组所有权
旧版Unix系统中，chown命令只能更改文件所有权，而不是用户组所有权。为了达到目的，使用一个独立的命令,chgrp来完成。除了限制多一点之外，chgrp命令与chown命令使用起来很相似。  
## 练习使用权限
一个例子，如何设置共享目录，假设有两个用户，分别是“bill”和“karen”。像设置一个共享目录，其中以Ogg Vorbis或MP3格式来存储他们的音乐文件。首先，用GNOME图形化用户管理工具创建一个以bill和karen为成员的用户组，用户组名为music，下一步，bill创建了存储音乐文件的目录：
```
$ sudo mkdir /usr/local/share/Music
password:
```
因为bill正在他的家目录之外操作文件，所以需要超级用户权限。这个目录创建之后，它具有以下所有权和权限：
```
$ ls -ld /usr/local/share/Music
drwxr-xr-x 2 root root 4096 2008-03-21 18:05 /usr/local/share/Music
```
这个目录由root用户拥有，并且具有权限755。为了使这个目录共享，允许（用户karen）写入，bill需要更改目录用户组所有权和权限：
```
$ sudo chown :music /usr/local/share/Music
$ sudo chomd 775 /usr/local/share/Music
$ ls -ld /usr/local/share/Music
drwxrwxr-x 2 root music 4096 2008-03-21 18:05 /usr/local/share/Music
```
我们拥有一个目录，/usr/local/share/Music,这个目录由root用户拥有，并且允许用户组music读取和写入。用户组music有两个成员bill和karen，这样bill和karen能够在目录/usr/local/share/Music中创建文件。其他用户能列出目录内容，但不能在其中创建文件。
但通过目前拥有的权限，在Music目录中创建的文件，只具有用户bill和karen的普通权限：
```
$ > /usr/local/share/Music/test_file
$ ls -l /usr/local/share/Music
-rw-r--r-- 1 bill bill 0 2008-03-24 20:03 test_file
```
存在两个问题，  
第一个，系统默认掩码是0022，这会禁止用户组成员编辑属于同组成员的文件。如果共享目录只包含文件，这就不是问题，但因为这个目录将会存储音乐，通常音乐会按照艺术家和唱片的层次结构来组织分类。所以用户组成员需要在同组其他成员创建的目录中创建文件和目录。我们将用户bill和karen使用的掩码值改为0002  
第二个，用户组成员创建的文件和目录的用户组，将会设置为用户的主要组，而不是用户组music。通过设置此目录的setgid位来解决这个问题。
```
$ sudo chomod g+s /usr/local/share/Music
$ ls -ld /usr/local/share/Music
drwxrwsr-x 2 root music 4096 2008-03-24 20:03 /usr/local/share/Music
```
看看新的权限是否解决了这个问题。bill把他的掩码值设为0002，删除先前的测试文件，并创建了一个新的测试文件和目录：
```
$ umask 0002
$ rm /usr/local/share/Music/test_file
$ > /usr/local/share/Music/test_file
$ mkdir /usr/local/share/Music/test_dir
$ ls -l /usr/local/share/Music
drwxrwsr-x 2 bill music 4096 2008-03-24 20:24 test_dir
-rw-rw-r-- 1 bill music 0 2008-03-24 20:22 test_file
$
```
这样，创建的文件和目录都具有正确的权限，允许用户组music的所有成员在目录Music中创建文件和目录。
注意umask命令设置的掩码值这能在当前shell会话中生效，若当前shell会话结束后，则必须重新设置。

## 更改用户密码
使用passwd命令，来设置或更改用户密码。命令语法如下所示：
```
passwd [user]
```
只要输入passwd命令，就能更改你的密码。shell会提示你输入你的旧密码和你的新密码：
```
$ passwd
(current) UNIX password:
New UNIX password:
```
passwd命令将会试着强迫你使用“强”密码。这意味：它会拒绝太短的密码，与先前相似的密码，字典中的单词作为密码，或者是太容易猜到的密码：
```
$ passwd
(current) UNIX password:
New UNIX password:
BAD PASSWORD: is too similar to the old one
New UNIX password:
BAD PASSWORD: it is WAY too short
New UNIX password:
BAD PASSWORD: it is based on a dictionary word
```
如果你具有超级用户权限，可以指定一个用户名作为passwd命令的参数，这样可以设置另一个用户的密码。还有其他passwd命令选项对超级用户有效，允许账号锁定，密码失效，等等。
## 进程
操作系统支持多任务，它给用户造成了一种假象，看起来像它同时能够做多件事情，事实上，它是快速地轮换执行这些任务的。Linux内核通过使用进程，来管理多任务。通过进程，Linux安排不同的程序等待使用CPU。
## 进程是怎样工作的
当系统启动时，内核先把一些它自己的程序初始化为进程，然后运行一个叫做init的程序。init，依次地，在运行一系列的称为init脚本的shell脚本（位于/etc），它们可以启动所有的系统服务。其中许多系统服务以守护（daemon）程序的形式实现，守护程序仅在后台运行，没有任何用户接口。这样，即使我们没有登录系统，至少系统也在忙于执行一些例行事物。  
一个程序可以发动另一个程序，这个事实在进程方案中，表述为一个父进程创建了一个子进程。  
内核维护每个进程的信息，以此来保持事情有序。例如，系统分配给每个进程一个数字，这个数字叫做进程ID或PID。PID号按升序分配，init进程的PID总是1.内核也对分配给每个进程的内存进行跟踪。像文件一样，进程也有所有者和用户ID，有效用户ID，等等。
## 查看进程
常用命令是ps
```
$ ps
PID TTY    TIME CMD
5198 pts/1  00:00:00 bash
10129 pts/1 00:00:00 ps
```
两个进程5198和进程10129，各自代表命令bash和ps。  
默认情况下，ps不会显示很多进程信息，只是列出与当前终端会话相关的进程。为了得到更多信息，需要加上一些选项。  
TTY是“Teletype”的简写，指进程的控制终端。这里，Unix展示它的年龄。TIME字段表示进程所消耗的CPU时间数量。  
如果给ps命令加上选项，可以得到更多关于系统运行状态的信息：
```
$ ps x
PID   TTY  STAT   TIME   COMMAND
2799  ?    Ssl    0:00   /usr/libexec/bonobo-activation-server -- ac
2820  ?    Sl     0:01   /usr/libexec/evolution-data-server-1.10 --

and many more...
```
加上“x”选项（注意没有开头的“-”字符），告诉ps命令，展示所有进程，不管它们由什么终端（如果有的话）控制。在TTY一栏中出现的“？”，表示没有控制终端。使用这个“x”选项，可以看到我们所拥有的每个进程的信息。
输出结果中，新添加了一栏，标题为STAT。STAT是“state”的简写，它揭示了进程当前状态：
|状态 |意义 |
|:-:|:-:|
|R |运行。进程正在运行或准备运行 |
|S |正在睡眠。进程正在等待一个事件，辟谷，一个按键或者网络数据包 |
|D |不可中断睡眠。进程正在等待I/O，比方说，一个磁盘驱动器的I/O。 |
|T |已停止。已经指示进程停止运行 |
|Z |一个死进程或“僵尸”进程。这是一个已经终止的子进程，但是它的父进程还没清空它。（父进程没有把子进程从进程表中删除） |
|`<` |一个高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的CPU时间。进程的这种属性叫做niceness。具有高优先级的进程据说是不好的（less nice），因为它占用了比较多的CPU时间，这样就给其他进程留下很少时间。 |
|N |低优先级进程。一个低优先级进程（一个“好”进程）只有当其他高优先级进程执行之后，才会得到处理器时间。 |

进程状态信息之后，可能还跟随其他的字符。这表示各种外来进程的特性。

另一个流行的选项组合是“aux”（不带开头的“-”字符）
```
$ ps aux
USER   PID  %CPU  %MEM   VSZ   RSS   TTY   STAT   START   TIME   COMMAND
root     1   0.0   0.0  2136   644   ?     Ss     Mar05   0:31   init
root     2   0.0   0.0     0     0   ?     S&lt;     Mar05   0:00   [kt]

and many more...
```
这个选项组合，能够显示属于每个用户的进程信息。使用这个选项，可以唤醒“BSD风格”的输出结果。Linux版本的ps命令，可以模拟几个不同Unix版本中的ps程序的行为。通过这些选项，得到额外的列。
|标题 |意思 |
|:-:|:-:|
|USER |用户ID。进程的所有者。 |
|%CPU |以百分比表示的CPU使用率 |
|%MEM |以百分比表示的内存使用率 |
|VSZ |虚拟内存大小 |
|RSS |进程占用的物理内存的大小，以千字节为单位。 |
|START |进程运行的起始时间。若超过24小时，则用天表示。 |

## 用top命令动态查看进程

虽然ps命令能够展示许多计算机运行状态信息，但是它只是提供，ps命令执行时刻的机器状态快照。为了看到更多动态的信息，我们使用top命令：
```
$ top
```
top程序连续显示系统进程更新的信息（默认情况下，每三分钟更新一次），“top”这个名字来源于这个事实，top程序是用来查看系统中“顶端”进程的。top显示结果由两部分组成：最上是系统概要，下面是进程列表，以CPU的使用率排序。
```
top - 14:59:20 up 6:30, 2 users, load average: 0.07, 0.02, 0.00
Tasks: 109 total, 1 running, 106 sleeping, 0 stopped, 2 zombie
Cpu(s): 0.7%us, 1.0%sy, 0.0%ni,98.3%id, 0.0%wa, 0.0%hi, 0.0%si
Mem:  319496k total,  314860k used,  4636k free,  19392k buff
Swap: 875500k total, 149128k used, 726372k free, 114676k cach
PID USER  PR  NI  VIRT  RES  SHR  S %CPU  %MEM  TIME+     COMMAND
6244 me   39  19 31752 3124 2188  S  6.3   1.0  16:24.42  trackerd
....
```
|行号 |字段 |意义 |
|:-:|:-:|:-:|
|1 |top |程序名 |
| |14:59:20 |当前时间 |
| |up 6:30 |正常运行时间。计算机从上次启动到现在所运行的时间。这个例子里，系统已经运行了六个半小时。 |
| |2 users |有两个用户登录系统。 |
| |load average: |加载平均值，即等待运行的进程数目，也就是处于运行状态的进程个数，这些进程共享CPU。展示的三个数值对应不同的时间周期。第一个是最后60秒的平均值，下一个是前5分钟的平均值，最后一个是前15分钟的平均值。若平均值低于1.0，则指示计算机工作不忙碌。 |
|2 |Tasks: |总结了进程数目和各种进程状态。 |
|3 |Cpu(s):|这一行描述了CPU正在执行的进程的特性。 |
| |0.7%us |0.7% of the CPU is beding used for user processes.这意味着进程在内核之外。 |
| |1.0%sy |1.0%的CPU时间被用于系统（内核）进程。 |
| |0.0%ni |0.0%的CPU时间被用于“nice”（低优先级）进程。|
| |98.3%id |98.3%的CPU时间是空闲的。 |
| |0.0%wa |0.0%的CPU时间来等待I/O。 |
|4|Mem: |展示物理内存的使用情况。 |
|5|Swap:|展示交换分区（虚拟内存）的使用情况。 |

top程序接受一系列从键盘输入的命令。h，显示程序的帮助屏幕，q，退出top程序。  
两个主要的桌面环境都提供了图形化应用程序，来显示与top程序相似的信息（和Windows中的任务管理器差别不多），但top程序要好于图形化版本，因为它运行速度快，并且消费很少的系统资源。  
## 控制进程
## 中断一个进程
在一个终端中，输入Ctrl-c,中断一个程序。使用它，许多（但不是全部）命令行程序可以被中断。  
## 把一个进程放置到后台（执行）
想让shell提示符返回，却没有终止xlogo程序。在程序命令之后，加上“&”字符，让它立即在后台运行。
```
$ xlogo &
[1] 28236
$
```
上述数字那条信息是shell特性的一部分，叫做工作控制。shell告诉我们已经启动了工作号为1（“[1]”），PID为28236的程序。

工作控制，jobs这个shell功能可以列出从终端中启动的任务。
```
$ jobs
[1]+ Running       xlogo&
```
## 进程返回到前台
在后台运行的进程对一切来自键盘的输入都免疫，也不能用Ctrl-c来中断它。使用fg命令，让一个进程返回前台执行：
```
$ jobs
[1]+ Running     xlogo &
$ fg %1
xlogo
```
fg命令之后，跟随一个百分号和工作序号（叫做jobspec）。如果只有一个后台任务，那么jobspec是可有可无的。输入Ctrl-c来终止xlogo程序。
## 停止一个进程
有时候想要停止进程而不终止它。即把一个前台进程移到后台等待(注意不是移到后台运行，而是移到后台等待。输入Ctrl-z，发现此时拖动xlogo的窗口里面叉子不跟着缩放，它已经停住了，通过fg移动前台或bg移到后台运行，里面的叉子又能缩放了。
```
$ xlogo
[1]+ Stopped   xlogo
$
```
为何要从命令行启动一个图形界面程序？
1. 你要启动的程序没在窗口管理器菜单中列出来
2. 从命令行启动一个程序，你能看到一些错误信息。
3. 从命令行启动图形界面程序 可使用有用的命令行选项

## Signals
kill命令用来“杀死”程序。
```
$ xlogo &
[1] 28401
$ kill 28401
[1]+ Terminated   xlogo
```
上例第二行也可以使用jobspec（例如，%1）来代替PID。
kill命令不是确切地“杀死”程序，而是给程序发送信号。信号是操作系统与程序间进行通信所采用的几种方式中的一种。
如之前看到的，使用Ctrl-c和Ctrl-z过程中。当终端接受了其中一个按键组合后，它会给在全端运行的程序发送一个信号。
使用Ctrl-c的情况下，发送INT（中断）信号，使用Ctrl-z时，发送TSTP（终端停止）信号。
## 通过kill命令给进程发送信号
kill命令被用来给程序发送信号。
```
kill [-signal] 
```
；如果在命令行中没有指定信号，那么默认情况下，发送TERM（终止）信号。kill命令被经常用来发送以下命令：
|编号 |名字 |含义 |
|:-:|:-:|:-:|
|1 |HUP |挂起。这是美好往昔的痕迹，那时候终端机通过电话线和调制解调器连接到远端的计算机。这个信号被用来告诉程序，控制的远端机已经“挂起”。发送这个信号到终端机上的前台程序，程序会终止。许多守护进程也使用这个信号，来重新初始化。这意味着，当发送这个信号到一个守护进程后，这个进程会重新启动，并且重新读取它的配置文件。Apache网络服务器守护进程就是一个例子。 |
|2 |INT |中断。实现和Ctrl-c一样的功能，由终端发送。通常，它会终止一个程序。 |
|9 |KILL |杀死。鉴于进程可能会选择不同的方式，来处理发送给它的信号，比如忽略掉信号。kill信号不是发送给目标进程的，而是内核立即终止这个进程，这种方式终止进程的话，它没有机会去做些“清理”工作，或者是保存劳动成果。因此，应该把KILL作为杀手锏，其他终止信号失败后，再使用它。 |
|15 |TERM |终止。这是kill命令发送的默认信号。如果程序仍然活着，可以接受信号，那么这个信号终止。 |
|18 |CONT |继续。在停止一段时间后，进程恢复运行。 |
|19 |STOP |停止。这个信号导致进程停止运行，而没有终止。如同KILL信号，它不被发送到目标进程，因此不能被忽略。 |


例如：
```
$ xlogo &
[1] 13546
$ kill -1 13546
[1]+ Hangup      xlogo
```
在后台启动xlog程序，然后通过kill命令，发送给它一个HUP信号。这个xlogo程序终止运行，并且shell指示这个后台进程已经接受了一个挂起信号。在看到这条信息之前，你可能需要多按几次enter键。  
注意，既可以用号码，也可以用名字，不过要在名字前面加上字母“SIG”，来指定所有发送的信号。
进程，和文件一样，拥有所有者，所以为了能够通过kill命令来给进程发送信号，你必须是进程的所有者（或者是超级用户）。
除了kill命令最常用的信号外，还有一些系统频繁使用的信号。以下是其它一些常用信号列表:
|编号 |名字 |含义 |
|:-:|:-:|:-:|
|3 |QUIT |退出 |
|11 |SEGV |段错误。如果一个程序非法使用内存，就会发送这个信号。也就是说，程序试图写入内存，而这个内存空间是不允许此程序写入的 |
|20 |TSTP |终端停止。当按下Ctrl-z组合键后，终端发送这个信号。不像STOP信号，TSTP信号由目标进程接收，且可能被忽略。 |
|28 |WINCH |改变窗口大小。当改变窗口大小时，系统会发送这个信号。一些程序，像top和less程序会响应这个信号，按照新窗口的尺寸，刷新显示的内容。 |

通过下面的命令可以得到一个完整的信号列表：
```
$ kill -l
```
## 通过kill命令给多个进程发送信号
可以通过killall命令，给匹配特定程序或用户名的多个进程发送信号。下面是killall命令的语法形式：
```
killall [-u user] [-signal] name...
```
例如：启动一对xlogo程序实例，然后终止它们：
```
$ xlogo &
[1] 18801
$ xlogo &
[2] 18802
$ killall xlogo
[1]-Terminated    xlogo
[2]+Terminated    xlogo
```
## 更多和进程相关的命令
|命令名 |命令描述 |
|:-:|:-:|
|pstree |输出一个树型结构的进程列表，这个列表展示了进程间父/子关系。 |
|vmstat |输出一个系统资源使用快照，包括内存，交换分区和磁盘I/O。为了看到连续的显示结果，在命令名后加上延时的时间（以秒为单位）。例如，“vmstat 5”。终止输出，按下Ctrl-c组合键。 |
|xload |一个图形界面程序，可以画出系统负载图形。 |
|tload |与xload程序相似，但是在终端中画出图形。使用Ctrl-c，来终止输出。 |

# shell环境
## 什么存储在环境变量中
shell在shell会话中维护着大量信息，这些信息称为（shell）环境。存储子啊shell环境中的数据被程序用来确定配置属性。然而大多数程序用配置文件来存储程序设置，某些程序也会查找存储在shell环境中的数值来调整他们的行为。
shell在环境中存储了两种基本类型的数据，虽然对于bash来说，很大程度上这些类型是不可辨别的。它们是环境变量和Shell变量。Shell是由bash存放的少量数据，而剩下的基本上都是环境变量。除了变量，shell也存储了一些可编程的数据，命令为别名和shell函数。
## 检查环境变量
既可以用bash内部命令set，也可以用printenv程序来查看什么存储在环境中。  
set可以显示shell和环境变量两者，
printenv只是显示环境变量
因为环境变量内容列表相当长，所以最好把每个命令的输出结果管道到less命令
```
$ printenv | less
```
printenv 命令也能够列出特定变量的数值：
```
$ printenv USER
me
```
当使用没有带选项和参数的set命令时，shell和环境变量二者都会显示，同时也会显示定义的shell函数。不同于printenv，set命令的输出结果按字母顺序排列：
```
$ set | less
```
也可以通过echo命令来查看一个变量的内容：
```
$ echo $HOME
/home/me
```
如果shell环境中的一个成员既不可用set命令也不可用printenv命令显示，则这个变量是别名。输入不带参数的alias命令来查看它们：
```
$ alias
alias l.='ls -d .* --color=tty'
alias ll-'ls -l --color=tty'
alias ls='ls --color=tty'
alias vi='vim'
alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'
```
## 一些有趣的变量
|变量 |内容 |
|:-:|:-:|
|DISPLAY |如果你正在运行图形界面环境，那这个变量就是你显示器的名字。通常，它是“:0”，意思是由X产生的第一个显示器 |
|EDITOR |文本编辑器的名字 |
|SHELL |shell程序的名字 |
|HOME |用户家目录 |
|LANG |定义了字符集以及语言编码方式 |
|OLD_PWD |先前工作目录 |
|PAGER |页输出程序的名字。这经常设置为/usr/bin/less |
|PATH |由冒号分开的目录列表，当你输入可执行程序名后，会搜索这个目录列表。 |
|PS1 |Prompt String 1.这个定义了你的shell提示符的内容。这个变量内容可以全面地定制。 |
|PWD |当前工作目录 |
|TERM |终端类型名。类Unix的系统支持许多终端协议，这个变量设置你的终端仿真器所用的协议。 |
|TZ |指定你所在的时区。大多数类Unix的系统按照UTC来维护计算机内部的时钟，然后应用一个由这个变量指定的偏差来显示本地时间 |
|USER |你的用户名 |

变量会因发行版本不同而不同。
## 如何建立shell环境
登录系统后，启动bash程序，并且会读取一系列称为启动文件的配置脚本，这些文件定义了默认的可供所有用户共享的shell环境。然后是读取更多位于我们自己家目录中的启动文件，这些启动文件定义了用户个人的shell环境。精确地启动顺序依赖于要运行的shell会话类型。有两种shell会话类型：一个是登录shell会话 ，另一个是非登录shell会话。  
登录shell会话会提示用户输入用户名和密码。当我们在GUI模式下运行终端会话时，非登录shell会话会出现。

登录shell会读取一个或多个启动文件：
|文件 |内容 |
|:-:|:-:|
|/etc/profile |应用于所有用户的全局配置脚本 |
|~/.bash_profile |用户私人的启动文件。可以用来扩展或重写全局配置脚本中的设置。 |
|~/.bash_login |如果文件~/.bash_profile没有找到，bash会尝试读取这个脚本 |
|~/.profile |如果文件~/.bash_profile或文件~/.bash_login都没有找到，bash会试图读取这个文件。这是基于Debian发行版的默认设置，比方说Ubuntu |

非登录shell会话会读取以下启动文件：
|文件 |内容 |
|:-:|:-:|
|/etc/bash.bashrc |应用于所有用户的全局配置文件 |
|~/.bashrc |用户私有的启动文件。可以用来扩展或重写全局配置脚本中的设置。 |

除了读取以上启动文件之外，非登录shell会话也会继承它们父进程的环境设置，通常是一个登录shell.
## 一个启动文件的内容

一个典型的.bash_profile文件（来自CentOS4系统）
```
# .bash_profile
# Get the aliases and functions
if [ -f ~/.bashrc ]; then
. ~/.bashrc
fi
# User specific environment and startup programs
PATH=$PATH:$HOME/bin
export PATH
```
这段代码：
```
if [-f -/.bashrc ]; then
. ~/.bashrc
fi
```
叫做一个if复合命令，上述代码翻译为
```
If the file ~/.bashrc exists,then
read the ~/.bashrc file.
```
这段代码就是一个登录shell得到.bashrc文件内容的方式。

shell是怎样知道到哪里找到我们在命令行中输入的命令的？比如，输入ls后，shell不会查找整个计算机系统，来找到/bin/ls（ls命令的绝对路径名），而是，它查找一个目录列表，这些目录包含在PATH变量中。  
PATH变量经常（但不总是，依赖于发行版）在/etc/profile启动文件中设置，通过这些代码：
```
PATH=$PATH:$HOME/bin
```
修改PATH变量，添加目录`$HOME/bin`到目录列表的末尾。这是一个参数展开的实例。
试看下面例子：
```
$ foo="This is some"
$ echo $foo
This is some
$ foo="$foo text."
$ echo $foo
This is some text.
```
使用这种技巧，可以把文本附加到一个变量值得末尾。通过添加字符串`$HOME/bin`到PATH变量值的末尾，则目录`$HOME/bin`就添加到了命令搜索目录列表中。

一些Debian发行版，例如Ubuntu，在登录的时候，会检测目录~/bin是否存在，若找到目录则把它动态地加到PATH变量中。
```
export PATH
```
这个export命令告诉shell让这个shell的子进程可以使用PATH变量的内容。
## 修改shell环境
既然知道了启动文件所在位置和它们所包含的内容，就可以修改它们来定制自己的shell环境。
## 我们应该修改哪个文件
按照通常的规则，添加目录到你的PATH变量或者是定义额外的环境变量，要把这些更改放置到.bash_profile文件中（后者其替代文件中，根据不同的发行版。例如，Ubuntu使用.profile文件）。对于其他的更改，要放到.bashrc文件中。除非你是系统管理员，需要为系统中的所有用户修改默认设置，那么则限定你只能对自己家目录下的文件进行修改。当然，有可能会更改/etc目录中的文件，比如说profile文件，而且在许多情况下，修改这些文件也是明智的。
## 文本编辑器
文本编辑器分为两种基本类型：图形化的和基于文本的编辑器。GNOME和KDE两者都包含一些流行的图形编辑器。GNOME自带一个叫做gedit的编辑器，这个编辑器通常在GNOME菜单中称为“文本编辑器”。KDE通常自带了三种编辑器，分别是（按照复杂度递增的顺序排列）kedit,kwrite,kate。  
有许多基于文本的编辑器，比如nano,vi,emacs。nano是一个简单的，易用的编辑器，它是pico编辑器的替代物，pico编辑器由PINE邮件套件提供。vi编辑器（在大多数Linux系统中被vim替代，vim是“Vi IMproved”的简写）是类Unix操作系统的传统编辑器。emacs编辑器最初由Richard Stallman写成。emacs是一个庞大的，多用途的，可做任何事情的变成环境。虽然emacs很容易获取，但大多数Linux系统很少默认安装它。
## 使用文本编辑器
所有的文本编辑器都可以在命令行中输入编辑器名字，加上你所想要编辑的文件来唤醒。如果所输入的文件名不存在，编辑器则会假定你想要创建一个新文件。下面是一个使用gedit的例子：
```
$ gedit some_file
```

当我们编辑一个重要的配置文件时，首先创建一个这个文件的备份。这样能避免在编辑文件时弄乱文件。创建文件.bashrc的备份文件，这样做：
```
$ cp .bashrc .bashrc.bak
```
备份文件的名字无关紧要，扩展名==“.bak”,".sav",".old",和".orig"==都是用来指示备份文件的流行方法。另外注意，cp命令会默默地重写存在的文件。
有了备份文件，启动nano，并且编辑文件.bashrc。
```
$ nano .bashrc
```
nano编辑器启动后，将会得到一个像下面一样的屏幕：
```
GNU nano 2.0.3
...
```
这个屏幕由上面的标头，中间正在编辑的文件文本和下面的命令菜单组成。因为设计nano是为了代替由电子邮件客户端提供的编辑器，所以它相当缺乏编辑特性。  
输入Ctrl-x来退出nano。在屏幕底层的菜单说明了这个命令。"^X"表示法意思是Ctrl-x。这是控制字符常见表示法。
保存是Ctrl-o,试着编辑：使用下箭头按键和/或下翻页按键，移动鼠标到文件最后一行，然后添加以下几行到文件.bashrc中：
```
umask 0002
export HISTCONTROL=ignoredups
export HISTSIZE=1000
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
```
你的发型版可能已经包含其中的一些行，但复制没有任何伤害。
下表是所添加行的意义：
|文本行 |含义 |
|:-:|:-:|
|umask 0002 |设置掩码来解决共享目录的问题 |
|export HISTCONTROL=ignoredups |使得shell的历史记录功能忽略一个命令，如果相同的命令已被记录。 |
|export HISTSIZE=1000 |增加命令历史大小，从默认500行扩大到1000行 |
|alias l.-'ls -d .* --color=auto' |创建一个新命令，叫做'l.',这个命令会显示所有以点开头的目录项。 |
|alias ll='ls -l --color=auto'|创建一个叫做‘ll’的命令，这个命令会显示长格式目录列表 |

考虑到附加物的意思在直觉上并不是明显的，所以添加注释到.bashrc中是个好主意。

```
# Change umask to make directory sharing easier
umask 0002
# Ignore duplicates in command history and increase
# history size to 1000 lines
export HISTCONTROL=ignoredups
export HISTSIZE=1000
# Add some helpful aliases
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
```

不管什么时候你修改配置文件时，给所做的修改加上注释。六个月后，谁也不急的改过什么。
Shell脚本和bash启动文件都使用“#”符号来开始注释。其它配置文件可能使用其它符号。  
经常看到配置文件中的一些行被注释掉，以此防止它们被受影响的程序使用。这样做是为了给读者在可能的配置选项方面一些建议，或者给出正确的配置语法实例。

## 激活我们的修改
我们对于.bashrc的修改不会生效，直到我们关闭终端会话，再重新启动一个新的会话，因为.bashrc文件只是在刚开始启动终端会话时读取。可以用下面命令强迫bash重新读取修改过的.bashrc文件：
```
$ source .bashrc
```
## vim简略版
|按键 |移动光标 |
|:-:|:-:|
|0 |移动到当前行的行首 |
|^ |移动到当前行的第一个非空字符 |
|`$` |移动到当前行的末尾 |
|Ctrl-f or Page Down |向下翻一页 |
|Ctrl-b or Page Up |向上翻一页 |
|numberG |移动到第number行，例如，1G移动到文件第一行 |
|G |移动到文件末尾 |

## 删除文本
|命令 |删除的文本 |
|:-:|:-:|
|x |当前字符 |
|3x |当前字符及其后的两个字符 |
|dd |当前行 |
|5dd |当前行及随后的四行文本 |
|dW |从光标位置开始到下一个单词的开头 |
|`d$` |从光标位置开始到当前行的行尾 |
|d0 |从光标位置开始到当前行的行首 |
|d^ |从光标位置开始到文本行的第一个非空字符 |
|dG |从当前行到文件的末尾 |
|d20G |从当前行到文件的第20行 |

## 剪切，复制和粘贴文本
上述d命令不仅删除文本，它还“剪切”文本。每次使用d命令，删除的部分被复制到一个粘贴缓冲区中（看做剪切板）。然后可执行p把剪切板中的文本粘贴到光标位置之后，或者是P命令把文本粘贴到光标之前。
y命令用来“拉”（复制）文本，和d命令剪切文本的方式差不多：
|命令 |复制的内容 |
|:-:|:-:|
|yy |当前行 |
|5yy |当前行及随后的四行文本 |
|yW |从当前光标位置到下一个单词的开头 |
|`y$` |从当前光标位置到当前行的末尾 |
|y0 |从当前光标位置到文本行的第一个非空字符 |
|y^ |从当前光标位置到文本行的第一个非空字符 |
|yG |从当前行到文件末尾 |
|y20G |从当前行到文件的第20行 |

## 连接行
vi对于行的概念相当严格。通常，不可能把光标移到行尾，再删除行尾结束符（回车符）来连接当前行和它下面的一行。由于这个原因，vi提供了一个特定的命令，大写的J（不要与小写的j混淆了，j是用来移动光标的）把行与行之间连接起来。
## 查找一行
f命令查找一行，移动光标到下一个所指定的字符上。例如，命令fa把光标定位到同一行中下一个出现“a”字符上。在一行中执行了字符查找命令后，通过输入分号来重复这个查找。
## 查找整个文件
输入“/”,再输入要查找的单词或短语，按下回车。光标就会移动到下一个包含所查找字符串的位置。通过n命令来重复先前的查找。
## 全局查找和替代
vi使用ex命令来执行查找和替代操作（vi中叫做“替换”）。把整个文件中的单词“Line”更改为“line”，输入以下命令：
```
:%s/Line/line/g
```
|条目 |含义 |
|:-:|:-:|
|： |冒号字符运行一个ex命令 |
|% |指定要操作的行数。%是一个快捷方式，表示从第一行到最后一行。另外，操作范围也可以用1，5来代替（因为我们的文件只有5行文本），或者用1，`\$` 来代替，意思是“从第一行到文件的最后一行”。如果省略了文本行的范围，那么操作只对当前行生效。 |
|s |指定操作，这种情况下是，替换（查找与替代） |
|/Line/line |查找类型与替换文本。 |
|g |这是“全局”的意思，意味着对文本行中所有匹配的字符串执行查找和替换操作。如果省略g，则只替换每个文本行中第一个匹配的字符串 |

也可以指定一个需要用户确认的替换命令。通过添加一个“c”字符到这个命令的末尾，来完成这个替换命令。
```
:%s/line/Line/gc
```
这个命令会把我们的文件恢复先前的模样，然而，在执行每个替换命令之前，vi会停下来，通过下面的信息，来要求我们确认这个替换：
```
replace with Line (y/n/a/q/l/^E/^Y)?
```
|按键 |行为 |
|:-:|:-:|
|y |执行替换操作 |
|n |跳过这个匹配实例 |
|a |对这个及随后所有匹配的字符串执行替换操作 |
|q or esc |退出替换操作 |
|l |执行这次替换并退出。l是“last”的简写 |
|Ctrl-e,Ctrl-y |分别是向下滚动和向上滚动。用于查看建议替换的上下文 |
## 编辑多个文件
同时能够编辑多个文件是很有用的。你可能需要更改多个文件或者从一个文件复制内容到另一个文件。通过vi，我们可以打开多个文件来编辑，只要在命令行中指定要编辑的文件名。
```
vi file1 file2 file3...
```
## 文件之间转换
同时编辑多个文件时，从这个文件转到下一个文件，使用ex命令
```
:n
```
回到先前的文件使用：
```
:N
```
当我们从一个文件移到另一个文件时，如果当前文件没有保存修改，vi会阻止我们转换文件，这是vi强制执行的政策。在命令之后添加感叹号，可以强迫vi放弃修改而转换文件。

上面所描述的转换方法，vim也提供了一些ex命令，这些命令使多个文件更容易管理。我们可以查看正在编辑的文件列表，使用:buffers命令。运行这个命令后，屏幕顶部就会显示出一个文件列表：
```
:buffers
1 #   "foo.txt"         line 1
2 %a  "ls-output.txt"   line 0
Press ENTER or type command to continue
```
注意：你不能通过:n或:N命令在由：e命令加载的文件之间进行切换。这时要使用:buffer命令，其后加上缓冲区号码，来转换文件。
## 插入整个文件到另一个文件
```
:r foo.txt
```
这个：r命令（是“read”的简称）把指定的文件插入到光标位置之前
## 保存工作
除了:w这个ex命令，还有几种方法：
在命令模式下，输入ZZ就会保存并退出当前文件。
这个：w命令也可以指定可选的文件名。这个的作用就如“Save As... ”。例如，如果我们正在编辑foo.txt文件，想要保存一个副本，叫做foo1.txt，那么可以执行以下命令：
```
:w foo1.txt
```
注意：与以往经验不同的是，当上面的命令以一个新名字保存文件时，它并没有更改你正在编辑的文件的名字。如果你继续编辑的话，你还是在编辑文件foo.txt，而不是foo1.txt

## 自定制shell提示符
## 解剖一个提示符
我们默认的提示符看起来像这样：
```
[me@linuxbox ~]$
```
它包含用户名，主机名和当前工作目录。提示符是由一个环境变量定义的，叫做PS1（是“prompt string one"的简写）。可以通过echo命令来查看PS1的内容。
```
$ echo $PS1
[\u@\h \W]\$
```
输出结果中：
|序列 |显示值 |
|:-:|:-:|
|\a |以ASCII格式编码的铃声，当遇到这个转义序列时，计算机会发出嗡嗡的响声。 |
|\d |以日，月，天格式来表示当前日期。例如，“Mon May 26" |
|\h |本地机的主机名，但不带末尾的域名 |
|\H |完整的主机名 |
|\j |运行在当前shell会话中的工作数。 |
|\l |当前终端设备名 |
|\n |一个换行符 |
|\r |一个回车符 |
|\s |shell程序名 |
|\t |以24小时制，hours:minutes:seconds的格式表示当前时间 |
|\T |以12小时制表示当前时间。 |
|\@ |以12小时制，AM/PM格式来表示当前时间。 |
|\A |以24小时制，hours:minutes格式表示当前时间 |
|\u |当前用户名 |
|\v  |shell程序的版本号 |
|\V |Version and release numbers of the shell |
|\w |当前工作目录名 |
|\W |当前工作目录名的最后部分 |
|\\! |当前命令的历史号 |
|\\# |当前shell会话中的命令数 |
|\\$ |这会显示一个"$"字符，除非你拥有超级用户权限。在那种情况下，会显示"#" |
|\\[ |标志着一系列一个或多个非打印字符的开始。这被用来嵌入非打印的控制字符，这些字符以某种方式来操作终端仿真器，比方说移动光标或是更改文本颜色。 |
|\\] |标志着非打印字符序列结束。 |

## 试试一些可替代的提示符设计
参照上述特殊字符列表，可以更改提示符来看一下效果。首先，把原来提示符字符串内容备份：把已有字符串复制到另一个shell变量中，这个变量是我们自己创造的：
```
$ ps1_old="$PS1"
```
我们新创建了一个叫做ps1_old的变量，并把变量PS1的值赋给ps1_old。通过echo命令可以证明我们的确复制了PS1的值。
```
$ echo $ps1_old
[\u@\h \W]\$
```
在终端会话中，我们能子啊任一时间复原提示符，只要简单地反向操作就可以：
```
$ PS1="$ps1_old"
```
## 添加颜色
略

## 移动光标
略

## 保存提示符
把提示符存储到.bashrc文件，可以使这个提示符永久存在。为了达到目的，把下面这两行添加到.bashrc文件中：
```
PS1='\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]<\u@\h \W>\$ '
export PS1
```

## 软件包管理
Linux发行版质量最重要的决定因素是软件包管理系统和其支持社区的持久性。  
软件包管理是指系统中一种安装和维护软件的方法。  
今天，通过从Linux发行版中安装的软件包，已经能满足许多人所有需要的软件。  
而早期Linux，人们需要下载和编辑源码来安装软件。

## 打包系统
大多数发行版分别属于两大包管理技术阵营：Debian的“.deb”,和红帽的“.rpm”。也有一些例外，比如Gentoo,Slackware和Foresight，但大多数会使用这两个基本系统中的一个。
|包管理系统 |发行版（部分列表） |
|:-:|:-:|
|Debian Style(.deb) |Debian,Ubuntu,Xandros,Linspire |
|Red Hat Style(.rpm) |Fedora,CentOS,Red Hat Enterprise Linux,OpenSUSE,Mandriva,PCLinuxOS |
## 软件包管理系统是怎样工作的
Linux系统中几乎所有的软件都可以在互联网上找到。其中大多数软件由发行商以包文件的形式提供，剩下的以源代码形式存在，可以手动安装。
## 包文件
在包管理系统中软件的基本单元是包文件。包文件是一个构成软件包的文件压缩集合。一个软件包可能由大量程序及支持这些程序的数据文件组成。除了安装文件之外，软件包文件也包括关于这个包的元数据，如软件包及其内容的文本说明。另外，许多软件包还包括预安装和安装后脚本，这些脚本用来在软件安装之前和之后执行配置任务。  
软件包文件是由软件包维护者创建的，他通常是（但不总是）一名软件发行商的雇员。软件维护者从上游提供商（程序作者）那里得到软件源码，然后编辑源码，创建软件包元数据以及所需要的安装脚本。通常，软件包维护者要把所做的修改应用到最初的源码当中，来提高此软件与Linux发行版其他部分的融合性。
## 资源库
虽然某些软件项目选择执行他们自己的打包和发布策略，但是现在大多数软件包是由发行商和感兴趣的第三方创建的。系统发行版的用户可以在一个中心资源库中得到这些软件包，这个资源库可能包含了成千上万个软件包，每一个软件包都是专门为这个系统发行版建立和维护的。  
因软件开发生命周期不同阶段的需要，一个系统发行版可能维护着几个不同的资源库。例如，通常会有一个“测试”资源库，其中包含刚刚建立的软件包，它们想要勇敢的用户来使用，在这些软件包正式发布之前，让用户查找错误。系统发行版经常会有一个“开发”资源库，这个资源库中保存着注定要包含到下一个主要版本中的半成品软件包。  
一个系统发行版可能也会拥有相关第三方的资源库。这些资源库需要支持一些因法律原因，比如说专利或者是DRM反规避问题，而不能被包含到发行版中的软件。可能最著名的案例就是那个加密的DVD支持，在美国这是不合法的。第三方资源库在这些软件专利和反规避法案不生效的国家中起作用。这些资源库通常完全地独立于它们所支持的资源库，想要使用它们，必须了解它们，手动地把它们包含到软件包管理系统的配置文件中。  
## 依赖性
程序很少是“孤立的”，而是依赖于其它软件组件来完成它们的工作。常见活动，以输入/输出为例，就是由共享程序例程来处理的。这些程序例程存储在共享库中，共享库不只为一个程序提供基本服务。如果一个软件包需要共享资源，比如说共享库，就说它有一个依赖。现代的软件包管理系统都提供了一些依赖项解析方法，以此来确保当安装软件包时，也安装了其所有的依赖程序。  
## 上层和底层软件包工具
软件包管理系统通常由两种工具类型组成：底层工具用来处理这些任务，比如安装和删除软件包文件，和上层工具，完成元数据搜索和依赖解析。
|发行版 |底层工具 |上层工具 |
|:-:|:-:|:-:|
|Debian-Style |dpkg |apt-get,aptitude |
|Fedora,Red Hat Enterprise Linux,CentOS |rpm |yum |
虽然所有基于Red Hat风格的发行版都依赖于相同的底层程序（rpm），但是它们却使用不同的上层工具。Fedora，Red Hat企业版，CentOS都使用yum。其他基于Red Hat风格的发行版提供了带有可比较特性的上层工具。
## 常见的软件包管理任务
底层工具也支持软件包文件的创建，但这超出了现在的讨论范围。在以下讨论中“package_name”这个术语是指软件包实际名称，而不是指“package_file”，它是包含在软件包中的文件名。  
## 查找资源库中的软件包
使用上层工具来搜索资源库元数据，可以根据软件包的名字和说明来定位它。
|风格 |命令 |
|:-:|:-:|
|Debian |apt-get update;apt-cache search search_string |
|Red Hat |yum search serch_string |
例如：搜索一个yum资源库来查找emacs文本编辑器，使用以下命令：
```
yum search emacs
```

## 从资源库中安装一个软件包
上层工具允许从一个资源库中下载一个软件包，并经过完全依赖解析来安装它。
|风格 |命令 |
|:-:|:-:|
|Debian |apt-get update;apt-get install package_name |
|Red Hat |yum install package_name |
例如：从一个apt资源库安装emacs文本编辑器：
```
apt-get update;apt-get install emacs
```
## 通过软件包文件来安装软件
如果从某处而不是从资源库中下载了一个软件包文件，可以使用底层工具来直接（没有经过依赖解析）安装它。
|风格 |命令 |
|:-:|:-:|
|Debian |dpkg --install package_file |
|Red Hat |rpm -i package_file |
例如：从一个并非资源库的网站下载了软件包文件emacs-22.1-7.fc7-i386.rpm,则可以通过这种方法来安装它：
```
rpm -i emacs-22.1-7.fc7-i386.rpm
```
注意：因为这项技术使用底层rpm程序来执行安装任务，所以没有运行依赖解析。如果rpm程序发现缺少了一个依赖，则会报错并退出。
## 卸载软件
可以使用上层或底层工具来卸载软件。
上层工具:
|风格 |命令 |
|:-:|:-:|
|Debian |apt-get remove package_name |
|Red Hat |yum erase package_name |
例如：从Debian风格的系统中卸载emacs软件包：
```
apt-get remove emacs
```
## 经过资源库来更新软件包
|风格 |命令 |
|:-:|:-:|
|Debian |apt-get update;apt-get upgrade |
|Red Hat |yum update |
例如：更新安装在Debian风格系统中的软件包:
```
apt-get update;apt-get upgrade
```
## 经过软件包文件来升级软件
|风格 |命令 |
|:-:|:-:|
|Debian |dpkg --install package_file |
|Red Hat |rpm -U package_file |
例如：把Red Hat系统中所安装的emacs版本更新到软件包文件emacs-22.1-7.fc7-i386.rpmz所包含的emacs版本。
```
rpm -U emacs-22.1-7.fc7-i386.rpm
```
注意：rpm程序安装一个软件包和升级一个软件包所用的选项是不同的，而dpkg程序所用的选项是相同的。
## 列出安装的软件包
下边中的命令可以用来显示安装到系统中的所有软件包列表：
|风格 |命令 |
|:-:|:-:|
|Debian |dpkg --list |
|Red Hat |rpm -qa |
## 确定是否安装了一个软件包
这些底端工具可以用来显示是否安装了一个指定的软件包：
|风格 |命令 |
|:-:|:-:|
|Debian |dpkg --status package_name |
|Red Hat |rpm -q package_name |
例如：确定是否Debian风格的系统中安装了这个emacs软件包：
```
dpkg --status emacs
```
## 显示所安装软件包的信息
|风格 |命令 |
|:-:|:-:|
|Debian |apt-cache show package_name |
|Red Hat |yum info package_name |

例如：查看Debian风格系统中emacs软件包的说明信息：
```
apt-cache show emacs
```
## 查找安装了某个文件的软件包
确定哪个软件包对所安装的某个特殊文件负责，使用下表中的命令：
|风格 |命令 |
|:-:|:-:|
|Debian |dpkg --search file_name |
|Red Hat |rpm -qf file_name |

例如：在Red Hat系统中，查看哪个软件包安装了/usr/bin/vim这个文
```
rpm -qf /usr/bin/vim
```

设备驱动不是系统发行版资源库中单独的项目，它们本身是Linux系统内核的一部分。一般来说，在Linux当中没有一个类似于“驱动盘”的东西。要不内核支持一个设备，要不不支持。反正Linux内核支持很多设备，事实上，多于Windows所支持的设备数目。当你需要的特定设备不被支持时，通常是由以下三种情况之一导致：
1. 设备太新。因为许多硬件供应商没有积极地支持Linux发展，那么编写内核驱动代码的任务就由一些Linux社区来承担，而这需要花费时间。
2. 设备太奇异。不是所有的发行版都包含每个可能的设备驱动。每个发行版会建立它们自己的内核，因为内核是可以配置的（这使得从手表到主机的每台设备上运行Linux称为可能），这样它们可能会忽略某个特殊设备。通过定位和下载驱动程序源码，可能需要你自己来编译和安装驱动。
3.硬件供应商隐藏信息。它们既不发布应用于Linux系统的驱动程序代码，也不发布技术文档来让某人创建它。这意味着硬件供应商试图保密此设备的程序接口。因为我们不想在计算机中使用保密的设备，所以我建议拆除这令人厌恶的硬件，把它扔到垃圾桶里。

## 存储媒介
## 挂载和卸载存储设备
Linux桌面系统的最新进展已经使存储设备管理对于桌面用户来说极其容易。大多数情况下，只要把设备连接到系统中，它就能工作。在过去（比如2004年），这个工作必须手动完成。在非桌面系统中（例如服务器中），这仍然是一个主要地手动过程，因为服务器经常有极端的存储需求和复杂的配置需求。

管理存储设备的第一步是把设备连接到文件系统树中。这个过程叫做挂载，允许设备参与到操作系统中。类Unix系统，像Linux，维护单一文件系统树，设备连接到各个结点上。这与MS-DOS和Windows等其他操作系统不同，Windows中每个设备（例如C:\,D:\,等）保持着单独的文件系统树。  
有一个叫做/etc/fstab的文件可以列出系统启动时要挂载的设备（典型地，硬盘分区）。下面是来自于Fedora 7 系统的/etc/fstab文件实例:
```
LABEL=/12       /        ext3   defaults       1 1
LABEL=/home     /home    ext3   defaults       1 2
LABEL=/boot     /boot    ext3   defaults       1 2
tmpfs           /dev/shm tmpfs  defaults       0 0
devpts          /dev/pts devpts gid=5,mode=620 0 0
sysfs           /sys     sysfs  defaults       0 0
proc            /proc    proc   defaults       0 0
LABEL=SWAP-sda3 /swap    swap   defaults       0 0
```

这个实例中所列出的大多数文件系统是虚拟的，前三个是硬盘分区。每行由六个字段组成：
|字段 |内容 |说明 |
|:-:|:-:|:-:|
|1 |设备名 |传统上，这个字段包含与物理设备相关联的设备文件的实际名字，比如说/dev/hda1（第一个IDE通道上第一个主设备分区）。然而今天的计算机，有很多热插拔设备（像USB驱动设备），许多现代Linux发行版用一个文件标签和设备相关联。当这个设备连接到系统中时，这个标签（当储存媒介格式化时，这个标签会被添加到存储媒介中）会被操作系统读取。那样的话，不管赋给实际物理设备哪个设备文件，这个设备仍然能被系统正确地识别。 |
|2 |挂载点 |设备所连接到的文件系统树的目录 |
|3 |文件系统类型 |Linux允许挂载许多文件系统类型。大多数本地的Linux文件系统是ext3,但也支持其他的，如FAT16(msdos），Fat32（vfat），NTFS（ntfs），CD-ROM（iso9660）等 |
|4 |选项 |文件系统可通过各种各样的选项来挂载。比如，挂载只读的文件系统，或挂载阻止执行任何程序的文件系统（一个有用的安全特性，避免删除媒介） |
|5 |频率 |一位数字，指定是否和在什么时间用dump命令来备份一个文件系统。 |
|6 |次序 |一位数字，指定fsck命令按照什么次序来检查文件系统。 |

## 查看挂载的文件系统列表
mount命令用来挂载文件系统。执行这个不带参数的命令。将会显示一系列当前挂载的文件系统：
```
[me@linuxbox ~]$ mount
/dev/sda2 on / type ext3 (rw)
proc on /proc type proc (rw)
sysfs on /sys type sysfs (rw)
devpts on /dev/pts type devpts (rw,gid=5,mode=620)
/dev/sda5 on /home type ext3 (rw)
/dev/sda1 on /boot type ext3 (rw)
tmpfs on /dev/shm type tmpfs (rw)
none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)
sunrpc on /var/lib/nfs/rpc_pipefs type rpc_pipefs (rw)
fusectl on /sys/fs/fuse/connections type fusectl (rw)
/dev/sdd1 on /media/disk type vfat (rw,nosuid,nodev,noatime,
uhelper=hal,uid=500,utf8,shortname=lower)
twin4:/musicbox on /misc/musicbox type nfs4 (rw,addr=192.168.1.4)
```

这个列表的格式是：设备 on 挂载点 type 文件系统类型（可选）
例如，第一行所示设备/dev/sda2作为根文件系统被挂载，文件系统类型是ext3,可读可写。
 
做个试验，在电脑上插入一张光盘，插入前后分别执行`mount`，发现插入后比之前多了一行
```
/dev/hcd on /media/live-1.0.10.8 type iso9660 (ro,noexec,nosuid,nodev,uid=500)
```
可以看到，CD-ROM已经挂载到了/media/live-1.0.10-8上，它的文件类型是iso9660（CD-ROM）  
需要注意：音频CD和CD-ROM不一样，音频CD不包含文件系统，这样在通常意义上，它就不能被挂载了。  
现在我们拥有CD-ROM光盘设备名字，让我们卸载这张光盘，并把它重新挂载到文件系统树的另一个位置。我们需要超级用户身份来进行操作，并且用umount来卸载光盘：
```
$ su -
Password:
# umount /dev/hdc
```
下一步是创建一个新的光盘挂载点。简单地说，一个挂载点就是文件系统树中的一个目录。它没有什么特殊的。它甚至不必是一个空目录，即使你把设备挂载到了一个非空目录上，你也不能看到这个目录中原来的内容，直到你卸载这个设备。创建一个新目录：
```
# mkdir /mnt/cdrom
```
把CD-ROM挂载到一个新的挂载点上，这个`-t`选项用来指定文件系统类型。
```
# mount -t iso9660 /dev/hdc /mnt/cdrom
```
然后，就可以通过这个新挂载点来查看CD-ROM的内容
```
# cd /mnt/cdrom
# ls
```
注意当我们试图卸载这个CD-ROM时，发生的事情：
```
# umount /dev/hdc
umount: /mnt/cdrom: device is busy
```
这是因为如果某个用户或进程正在使用一个设备，那么这个设备就不能被卸载。  
这种情况下，把工作目录更改到了CD-ROM的挂载点，这个挂载点导致设备忙碌。可以很容易修复这个问题通过把工作目录改到其他目录而不是这个挂载点。
```
# cd
# umount /dev/hdc
```
现在这个设备成功卸载了。

为什么卸载重要
鞋子啊一个设备需要把所有剩余的数据写入这个设备，所以设备可以被安全地移除。如果没有卸载设备，就移除了它，就有可能没有把注定要发送到设备中的数据输送完毕。在某些情况下，这些数据可能包含重要的目录更新信息，这将导致文件系统损坏，这是发生在计算机中的最坏的事情之一。

## 确定设备名称
以前，在开发Unix系统的时候，“更改一个磁盘驱动器”要用一辆叉车从机房中移除一台如洗衣机大小的设备。现代Linux桌面系统可以“自动地”挂载设备，然后再确定设备名称。  
列出目录/dev（所有设备的住所）的内容，我们会看到许多设备：
```
$ ls /dev
```
|模式 |设备 |
|:-:|:-:|
|/dev/fd* |软盘驱动器 |
|/dev/hd* |老系统中的IDE（PATA)磁盘。典型的主板包含两个IDE连接器或者是通道，每个连接器带有一根缆线，每根缆线上有两个硬盘驱动器连接点。缆线上的第一个驱动器叫做主设备，第二个叫做从设备。设备名称这样安排,/dev/hda是指第一通道上的主设备名，/dev/hdb是第一通道上的从设备名，/dev/hdc是第二通道上的主设备名。末尾的数字表示硬盘驱动器上的分区。例如，/dev/hda1是指系统中第一硬盘驱动器上的第一个分区，而/dev/hda则是指整个硬盘驱动器。 |
|/dev/lp* |打印机 |
|/dev/sd* |SCSI磁盘。在最近的Linux系统中，内核把所有类似于磁盘的设备（包括PATA/SATA硬盘，闪存，和USB存储设备，比如可移动的音乐播放器和数码相机）看做SCSI磁盘。剩下的命令系统类似于上述旧的/dev/hd*命令方案 |
|/dev/sr* |光盘（CD/DVD读取器和烧写器） |

我们经常看到符号链接比如说/dev/cdrom,/dev/dev和/dev/floppy,它们指向实际的设备文件，提供这些链接是为了方便使用。如果你工作的系统不能自动挂载可移动的设备，你可以使用下面的技巧来决定当可移动设备连接后，它是怎样被命名的。首先，启动一个实时查看文件/var/log/messages（你可能需要超级用户权限）
```
$ sudo tail -f /var/log/messages
```

这个文件的最后几行会被显示，然后停止。下一步，插入可移动设备。在这个例子里，我们将使用一个16MB闪存。瞬间，内核就会发现这个设备，并探测它：
```
Jul 23 10:07:53 linuxbox kernel: usb 3-2: new full speed USB device
using uhci_hcd and address 2
Jul 23 10:07:53 linuxbox kernel: usb 3-2: configuration #1 chosen
from 1 choice
Jul 23 10:07:53 linuxbox kernel: scsi3 : SCSI emulation for USB Mass
Storage devices
Jul 23 10:07:58 linuxbox kernel: scsi scan: INQUIRY result too short
(5), using 36
Jul 23 10:07:58 linuxbox kernel: scsi 3:0:0:0: Direct-Access Easy
Disk 1.00 PQ: 0 ANSI: 2
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] 31263 512-byte
hardware sectors (16 MB)
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Write Protect is
off
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Assuming drive
cache: write through
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] 31263 512-byte
hardware sectors (16 MB)
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Write Protect is
off
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Assuming drive
cache: write through
Jul 23 10:07:59 linuxbox kernel: sdb: sdb1
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Attached SCSI
removable disk
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: Attached scsi generic
sg3 type 0
```

显示再次停止之后，输入Ctrl-c，重新得到提示符。输出结果的有趣部分是一再提及“[sdb]”，这正好符和我们期望的SCSI磁盘设备名称。这道这一点后，有两行输出变得颇具启发性：
```
Jul 23 10:07:59 linuxbox kernel: sdb: sdb1
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Attached SCSI
removable disk
```
这告诉我们这个设备名称是/dev/sdb指整个设备，/dev/sdb1是这个设备的第一分区。  
使用`tail -f /var/log/messages`技巧是一个很不错的方法，可以实时观察系统的一举一动。  

既然知道了设备名称，我们就可以挂载这个闪存驱动器了：
```
[me@linuxbox ~]$ sudo mkdir /mnt/flash
[me@linuxbox ~]$ sudo mount /dev/sdb1 /mnt/flash
[me@linuxbox ~]$ df
Filesystem 1K-blocks Used Available Use% Mounted on
/dev/sda2 15115452 5186944 9775164 35% /
/dev/sda5 59631908 31777376 24776480 57% /home
/dev/sda1 147764 17277 122858 13% /boot
tmpfs 776808 0 776808 0% /dev/shm
/dev/sdb1 15560 0 15560 0% /mnt/flash
```
这个设备名称会保持不变只要设备与计算机保持连接且计算机不会重新启动。

## 创建新的文件系统
如果想用Linux本地文件系统来重新格式化闪存驱动器，而不是它现用的FAT32系统。这涉及到两个步骤：1 （可选的）创建一个新的分区布局若已存在的分区不是我们喜欢的。 2 在这个闪存上创建一个新的空的文件系统。  
## 用fdisk命令操作分区
fdisk程序允许我们直接在底层与类似磁盘的设备（比如说硬盘驱动器和闪存驱动器）进行交互。使用这个工具可以在设备上编辑，删除，和创建分区。以我们的闪存驱动器为例，首先我们必须卸载它（如果需要的话），然后调用fdisk程序，如下所示：
```
$ sudo umount /dev/sdb1
$ sudo fdisk /dev/sdb
```
注意我们必须指定设备名称，就整个设备而言，而不是通过分区号。程序启动后，我们将看到以下提示：
```
Command (m for help):
```
输入“m”会显示程序菜单：
```
Command action
a       toggle a bootable flag
....
```
我们想要做的第一件事情是检查已存在的分区布局。输入“p”会打印出这个设备的分区表：
```
Command (m for help): p

Disk /dev/sdb: 16 MB, 16006656 bytes
1 heads, 31 sectors/track, 1008 cylinders
Units = cylinders of 31 * 512 = 15872 bytes

Device Boot  Start    End   Blocks    Id   System
/dev/sdb1        2   1008    15608+    b  w95 FAT32
```

可以看到，16MB的设备只有一个分区，此分区占用了可用的1008个柱面中的1006个，并被标识为Windows 95 FAT32分区。有些程序会使用这个标志符来限制一些可以对磁盘所做的操作，但大多数情况下更改这个标志符没有危害。  
在上面列表中，我们看到ID号码“b”被用来指定这个已存在的分区。  
要查看可用的分区类型列表，参考之前的程序菜单，我们会看到以下选项：
```
l list known partition types
```
如果在提示符下输入“l”，就会显示一个很长的可能类型列表。在它们之中会看到“b”为已存在分区类型的ID号，而“83”是针对Linux系统的ID号。  
回到之前的菜单，看到这个选项来更改分区ID号
```
t change a partition's system id
```
先输入“t”，再输入新的ID号：
```
Command (m for help): t
Selected partition 1
Hex code (type L to list codes): 83
Changed system type of partition 1 to 83 (Linux)
```
这就完成了需要做的修改。到目前为止，还没有接触这个设备（所有修改都存储在内存中，而不是在此物理设备中），所以我们将会把修改过的分区表写入此设备，再退出。为此，我们在提示符下输入“w”：  

```

```
```
Command (m for help): w
The partition table has been altered!
Calling ioctl() to re-read partition table.
WARNING: If you have created or modified any DOS 6.x
308partitions, please see the fdisk manual page for additional
information.
Syncing disks.
```
如果已经决定保持设备不变，可在提示符下输入“q”，这将退出程序而没有改写更改。可以安全地忽略警告信息。
## 用mkfs命令创建一个新的文件系统
完成了分区编辑工作后，可以在闪存驱动器上创建一个新的文件系统。使用mkfs（“make fiel system”的简写）能创建各种格式的文件系统。在此设备上创建一个ext3文件系统，使用“-t”选项来指定这个“ext3”系统类型，随后是我们要格式化的设备分区名称：
```
[me@linuxbox ~]$ sudo mkfs -t ext3 /dev/sdb1
mke2fs 1.40.2 (12-Jul-2007)
Filesystem label=
OS type: Linux
Block size=1024 (log=0)
Fragment size=1024 (log=0)
3904 inodes, 15608 blocks
780 blocks (5.00%) reserved for the super user
First data block=1
Maximum filesystem blocks=15990784
2 block groups
8192 blocks per group, 8192 fragments per group
3091952 inodes per group
Superblock backups stored on blocks:
8193
Writing inode tables: done
Creating journal (1024 blocks): done
Writing superblocks and filesystem accounting information: done
This filesystem will be automatically checked every 34 mounts or
180 days, whichever comes first. Use tune2fs -c or -i to override.
[me@linuxbox ~]$
```
当ext3被选为文件系统类型时，这个程序会显示许多信息。若把这个设备重新格式化为它最初的FAT32文件系统，指定“vfat”作为文件系统类型：
```
sudo  mkfs -t vfat /dev/sdb1
```
任何时候添加额外的存储设备到系统中时，都可以使用这个分区和格式化过程。同样的操作可以被应用到内部硬盘和其它可移动的存储设备（例如USB硬盘驱动器）。
## 测试和修复文件系统
之前讨论的/etc/fstab文件中，每行的末尾可以看到一些神秘数字。每次系统启动时，在挂载系统之前，都会按照管理检查文件系统的完整性。这个任务由fsck程序（是“file system check”的简写）完成。每个fstab项中的最后一个数字指定了设备的检查顺序。在上面的实例中，可以看到首先检查根文件系统，然后是home和boot文件系统。若最后一个数字是零则响应设备不会被检查。
除了检查文件系统完整性之外，fsck还能修复受损文件系统，其成功度依赖于损坏的数量。在类Unix文件系统中，文件恢复的部分被放置于lost+found目录里面，位于每个文件系统的根目录下面。
检查我们的闪存驱动器（首先应该卸载），执行下面操作：
```
[me@linuxbox ~]\$ sudo fsck /dev/sdb1
fsck 1.40.8 (13-Mar-2008)
e2fsck 1.40.8 (13-Mar-2008)
/dev/sdb1: clean, 11/3904 files, 1661/15608 blocks
```
文件系统损坏情况相当罕见，除非硬件存在问题，如磁盘驱动器故障。在大多数系统中，系统启动阶段若探测到文件系统已经损坏了，则会导致系统停止下来，在系统继续执行之前，会指导你运行fsck程序。  
在Unix文化中，“fsck”这个单词往往会被用来代替一个流行的词，“fsck”和这个词共享了三个字母。这个尤其适用，因为你可能会说出上文提到的词，若你发现自己处于这种情况下，被强制来运行fsck命令时。
## 格式化软盘
略
## 直接把数据移入/出设备
虽然通常认为计算机中的数据以文件形式来组织数据，也可以“原始的”形式来考虑数据。一个磁盘驱动器，由大量数据“块”组成，而操作系统却把这些数据块看作目录和文件。如果把磁盘驱动器简单地看成一个数据块大集合，就能执行有用的任务，如克隆设备。  
dd程序能执行此任务。它可以把数据块从一个地方复制到另一个地方。它使用独特的语法（由于历史原因）：
```
dd if=input_file of=output_file [bs=block_size[count=blocks]]
```
假如有两个相同容量的USB闪存驱动器，并且要精确地把第一个驱动器（中的内容）复制给第二个。如果连接两个设备到计算机上，它们各自被分配到设备/dev/sdb和/dev/sdc上，这样就能通过下面命令把第一驱动器中的所有数据复制到第二个驱动器中。
```
dd if=/dev/sdb of=/dev/sdc
```
或者，如果只有一个驱动器被连接到计算机上，可以把它的内容复制到一个普通文件中供以后恢复或复制数据：
```
dd if=/dev/sdb of=flash_drive.img
```

警告！dd命令非常强大。虽然它的名字来自于“数据定义”，有时候也把它叫做“清除磁盘”，因为用户经常会误输入if或of的规范。在按下回车键之前，要再三检查输入与输出规范。
## 创建CD-ROM映像
写入一个可记录的CD-ROM（一个CD-R或者是CD-RW）由两步组成；首先，构建一个iso映像文件，这就是一个CD-ROM的文件系统映像，第二步，把这个映像文件写入到CD-ROM媒介中。
## 创建一个CD-ROM的映像拷贝
如果想要制作一张现有CD-ROM的iso映像，可以使用dd命令来读取CD-ROM中的所有数据块，并把它们复制到本地文件中。比如有一张Ubuntu CD，用它来制作一个iso文件。插入这张CD后，确定它的设备名称（假定是/dev/sdrom），然后：
```
dd if=/dev/cdrom of=ubuntu.iso
```
这项技术也适用于DVD光盘，但不能用于CD，因为它们不使用文件系统来存储数据。对于音频CD，看一下cdrdao命令。
## 从文件集合中创建一个映像
创建一个包含目录内容的iso映像文件，使用genisoimage程序。首先创建一个目录，这个目录包含了要包括到此映像中的所有文件，然后执行这个genisoimage命令来创建映像文件。例如，如果我们已经创建了一个叫做~/cd-rom-files的目录，然后用文件填充此目录，再通过下面的命令来创建一个叫做cd-rom.iso的映像文件：
```
genisoimage -o cd-rom.iso -R -J -/cd-rom-files
```
“-R”选项添加元数据为Rock Ridge扩展，这允许使用长文件名和PSIX风格的文件权限。“-J”选项使Joliet扩展生效，这样Windows中就支持长文件名了。
## 写入CD-ROM镜像
有一个映像文件后，可以把它烧写到光盘中。下面讨论的大多数命令对可记录的CD-ROM和DVD媒介都适用。
## 直接挂载一个ISO镜像
有个诀窍，可以用来挂载iso映像文件，虽然此文件仍然在我们的硬盘中，但我们当作它已经在光盘中了。添加“-o loop”选项来挂载（同时带有必需的“-t iso9660”文件系统类型），挂载这个映像文件就好像它是一台设备，把它连接到文件系统树上：
```
mkdir /mnt/iso_image
mount -t iso9660 -o loop image.iso /mnt/iso_image
```
上例中，创建了一个挂载点叫做/mnt/iso_image，然后把此映像文件image.iso挂载到挂载点上。映像文件被挂载之后，可以把它当做，就好像是一张真正的CD-ROM或DVD。当不再需要此映像文件后，记得卸载。
## 清除一张可重写入的CD-ROM
用wodim命令，指定设备名称和清空的类型。几种清空类型中，最小（且最快）的是“fast”类型：
```
wodim dev=/dev/cdrw blank=fast
```
## 写入镜像
写入一个映像文件，再次使用wodim命令，指定光盘设备名称和映像文件名：
```
wodim dev=/dev/cdrw image.iso
```
除了设备名称和映像文件之外，wodim命令还支持非常多选项。常见个两个选项是，“-v”可详细输出，和“-dao”以disk-at-once模式写入光盘。如果你正在准备一张光盘为的是商业复制，那么应该使用这种模式。wodim命令的默认模式是track-at-once ，这对于录制音乐很有用。

通常验证一下我们已经下载的iso映像文件的完整性很有用处。大多情况下，iso映像文件的贡献者会提供一个checksum文件。一个checksum是一个神奇的数学运算的计算结果，这个数学计算会产生一个能表示目标文件内容的数字。如果目标文件的内容即使更改一个二进制位，checksum的结果将会非常不一样。生成checksum数字的最常见方法是使用md5sum程序。它会产生一个独一无二的十六进制数字：
```
md5sum image.iso
34e354760f9bb7fbf85c96f6a3f94ece   image.iso
```
当你下载完映像文件后，应该对映像文件执行md5sum命令，然后把运行结果与发行商提供的md5sum数值作比较。


## 网络系统
当谈及网络系统层面，几乎任何东西都能由Linux来实现。Linux被用来创建各式各样的网络系统和装置，包括防火墙，路由器，名称服务器，网络连接式存储设备等。 
## 检查和检测网络
## ping
ping发送一个特殊的网络数据包，叫做IMCP ECHO_REQUEST，到一台指定的主机。大多数接收这个包的网络设备将会回复它，来允许网络连接验证。  
注意：大多数网络设备（包括Linux主机）都可以配置为忽略这些数据包。通常，这样做是出于网络安全原因，部分地遮蔽一台主机免受一个潜在攻击者的侵袭。配置防火墙来阻塞IMCP流量也很普遍。  
例如，看看能否连接到网站linuxcommand.org，可以这样吧使用ping命令：
```
ping linuxcommand.org
```
一旦启动，ping命令会持续在特定的时间间隔内（默认是一秒）发送数据包，直到它被中断。
按下Ctrl-c，中断这个命令后，ping打印出运行统计信息。一个正常工作的网络会报告零个数据包丢失。一个成功执行的“ping”命令会意味着网络的各个部件（网卡，电缆，路由，网关）都处于正常的工作状态。
## traceroute
traceroute程序（一些系统使用相似的tracepath程序代替）会显示从本地到指定主机要经过的所有“跳数”的网络流量列表。如：
```
traceroute slashdot.org
```
命令输出如下：
```
traceroute to slashdot.org (216.34.181.45), 30 hops max, 40 byte
packets
1 ipcop.localdomain (192.168.1.1) 1.066 ms 1.366 ms 1.720 ms
2 * * *
3 ge-4-13-ur01.rockville.md.bad.comcast.net (68.87.130.9) 14.622
ms 14.885 ms 15.169 ms
4 po-30-ur02.rockville.md.bad.comcast.net (68.87.129.154) 17.634
ms 17.626 ms 17.899 ms
5 po-60-ur03.rockville.md.bad.comcast.net (68.87.129.158) 15.992
ms 15.983 ms 16.256 ms
6 po-30-ar01.howardcounty.md.bad.comcast.net (68.87.136.5) 22.835
...
```
可看到，连接测试系统到slashdot.org网站需要经由16个路由器。对于那些提供标识信息的路由器，我们能看到它们的主机名，IP地址和性能数据，这些数据包括三次从本地到此路由器的往返时间样本。对于那些没有提供标识信息的路由器（由于路由器配置，网络拥塞，防火墙等方面的原因），我们会看到几个星号。
## netstat
netstat程序被用来检查各种各样的网络设置和统计数据。使用“-ie”选项，能够查看系统中的网络接口：
```
[me@linuxbox ~]\$ netstat -ie
eth0 Link encap:Ethernet HWaddr 00:1d:09:9b:99:67
     inet addr:192.168.1.2 Bcast:192.168.1.255 Mask:255.255.255.0
     inet6 addr: fe80::21d:9ff:fe9b:9967/64 Scope:Link
     UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
     RX packets:238488 errors:0 dropped:0 overruns:0 frame:0
     TX packets:403217 errors:0 dropped:0 overruns:0 carrier:0
     collisions:0 txqueuelen:100 RX bytes:153098921 (146.0 MB) TX
     bytes:261035246 (248.9 MB) Memory:fdfc0000-fdfe0000
lo
     Link encap:Local Loopback
     inet addr:127.0.0.1 Mask:255.0.0.0
```
上例中，有两个网络接口，eth0，是因特网接口，lo是内部回环网络接口，它是一个虚拟接口，系统用它来“自言自语”  
执行日常网络诊断时，注意每个网络接口第四行开头出现的单词“UP”，说明这个网络接口已经生效，还有第二行中inet addr字段出现的有效IP地址。对于使用DHCP（动态主机配置协议）的系统，在这个字段中的一个有效IP地址证明了DHCP工作正常。
使用这个“-r”选项会显示内核的网络路由表。这展示了系统是如何配置网络之间发送数据包的。
```
[me@linuxbox ~]\$ netstat -r
Kernel IP routing table
Destination Gateway Genmask Flags MSS Window
irtt Iface
192.168.1.0 * 255.255.255.0 U 0 0 0 eth0
default 192.168.1.1 0.0.0.0 UG 0 0 0 eth0
```
上例可见，位于防火墙之内的局域网中，一台客户端计算机的典型路由表。第一行显示了目的地192.168.1.0.IP地址以零结尾是指网络，而不是个人主机，所以这个目的地意味着局域网中的任何一台主机。下一个字段，Gateway，是网关（路由器）的名字或IP地址，用它来连接当前的主机和目的地的网络。若这个字段显示一个星号，则表明不需要网关。  
最后一行包含目的地default。指的是发往任何表上没有列出的目的地网络的流量。
## 网络中传输文件
## ftp
ftp命令的名字来源于其所使用的协议，即文件传输协议。FTP被广泛地用来从因特网上下载文件。大多网络浏览器都支持FTP，你经常可以看到它们的URI以协议ftp://开头。ftp程序先于网络浏览器存在，ftp程序可用来与FTP服务器进行通信，FTP服务器就是存储文件的计算机，这些文件能够通过网络下载和上传。  
FTP（它的原始形式）并不是安全的，因为它会以明码形式发送账号的姓名和密码。这就意味着这些数据没有加密。因此，几乎因特网中所有FTP服务器都是匿名的。一个匿名服务器能允许任何人使用注册名"anonymous"和无意义的密码登录系统。


